Grammar:

Rule 0     S' -> program
Rule 1     program -> stmt_set
Rule 2     stmt_set -> stmt_set block
Rule 3     stmt_set -> stmt_set block ;
Rule 4     stmt_set -> stmt_set stmt
Rule 5     stmt_set -> stmt_set stmt ;
Rule 6     stmt_set -> block
Rule 7     stmt_set -> block ;
Rule 8     stmt_set -> stmt
Rule 9     stmt_set -> stmt ;
Rule 10    stmt -> RETURN innerlist
Rule 11    stmt -> PRINT innerlist
Rule 12    stmt -> CONTINUE
Rule 13    stmt -> BREAK
Rule 14    stmt -> ID DIVASSIGN expr  [precedence=left, level=1]
Rule 15    stmt -> ID MULASSIGN expr  [precedence=left, level=1]
Rule 16    stmt -> ID SUBASSIGN expr  [precedence=left, level=1]
Rule 17    stmt -> ID ADDASSIGN expr  [precedence=left, level=1]
Rule 18    stmt -> expr = expr  [precedence=left, level=1]
Rule 19    stmt -> FOR ID = expr : expr block
Rule 20    stmt -> WHILE ( expr ) block
Rule 21    stmt -> IF ( expr ) block
Rule 22    stmt -> IF ( expr ) block ELSE block  [precedence=nonassoc, level=3]
Rule 23    stmt -> expr
Rule 24    block -> stmt ;
Rule 25    block -> stmt
Rule 26    block -> { stmt_set }
Rule 27    expr -> expr [ expr , expr ]
Rule 28    expr -> [ outerlist ]
Rule 29    expr -> term
Rule 30    expr -> expr NEQ expr  [precedence=nonassoc, level=4]
Rule 31    expr -> expr EQU expr  [precedence=nonassoc, level=4]
Rule 32    expr -> expr GEQ expr  [precedence=nonassoc, level=4]
Rule 33    expr -> expr LEQ expr  [precedence=nonassoc, level=4]
Rule 34    expr -> expr > expr  [precedence=nonassoc, level=4]
Rule 35    expr -> expr < expr  [precedence=nonassoc, level=4]
Rule 36    expr -> ( expr )
Rule 37    expr -> expr '  [precedence=left, level=8]
Rule 38    expr -> - expr  [precedence=right, level=7]
Rule 39    expr -> expr DOTDIV expr  [precedence=left, level=6]
Rule 40    expr -> expr DOTMUL expr  [precedence=left, level=6]
Rule 41    expr -> expr DOTSUB expr  [precedence=left, level=5]
Rule 42    expr -> expr DOTADD expr  [precedence=left, level=5]
Rule 43    expr -> expr / expr  [precedence=left, level=6]
Rule 44    expr -> expr * expr  [precedence=left, level=6]
Rule 45    expr -> expr - expr  [precedence=left, level=5]
Rule 46    expr -> expr + expr  [precedence=left, level=5]
Rule 47    outerlist -> [ innerlist ]
Rule 48    outerlist -> outerlist , [ innerlist ]
Rule 49    innerlist -> expr
Rule 50    innerlist -> innerlist , expr
Rule 51    term -> ID
Rule 52    term -> STRING
Rule 53    term -> FLOATNUM
Rule 54    term -> INTNUM
Rule 55    term -> EYE ( expr )
Rule 56    term -> ONES ( expr )
Rule 57    term -> ZEROS ( expr )

Terminals, with rules where they appear:

'                    : 37
(                    : 20 21 22 36 55 56 57
)                    : 20 21 22 36 55 56 57
*                    : 44
+                    : 46
,                    : 27 48 50
-                    : 38 45
/                    : 43
:                    : 19
;                    : 3 5 7 9 24
<                    : 35
=                    : 18 19
>                    : 34
ADDASSIGN            : 17
BREAK                : 13
CONTINUE             : 12
DIVASSIGN            : 14
DOTADD               : 42
DOTDIV               : 39
DOTMUL               : 40
DOTSUB               : 41
ELSE                 : 22
EQU                  : 31
EYE                  : 55
FLOATNUM             : 53
FOR                  : 19
GEQ                  : 32
ID                   : 14 15 16 17 19 51
IF                   : 21 22
INTNUM               : 54
LEQ                  : 33
MULASSIGN            : 15
NEQ                  : 30
ONES                 : 56
PRINT                : 11
RETURN               : 10
STRING               : 52
SUBASSIGN            : 16
WHILE                : 20
ZEROS                : 57
[                    : 27 28 47 48
]                    : 27 28 47 48
error                : 
{                    : 26
}                    : 26

Nonterminals, with rules where they appear:

block                : 2 3 6 7 19 20 21 22 22
expr                 : 14 15 16 17 18 18 19 19 20 21 22 23 27 27 27 30 30 31 31 32 32 33 33 34 34 35 35 36 37 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 49 50 55 56 57
innerlist            : 10 11 47 48 50
outerlist            : 28 48
program              : 0
stmt                 : 4 5 8 9 24 25
stmt_set             : 1 2 3 4 5 26
term                 : 29


state 0

    (0) S' -> . program
    (1) program -> . stmt_set
    (2) stmt_set -> . stmt_set block
    (3) stmt_set -> . stmt_set block ;
    (4) stmt_set -> . stmt_set stmt
    (5) stmt_set -> . stmt_set stmt ;
    (6) stmt_set -> . block
    (7) stmt_set -> . block ;
    (8) stmt_set -> . stmt
    (9) stmt_set -> . stmt ;
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    program                        shift and go to state 1
    stmt_set                       shift and go to state 2
    block                          shift and go to state 3
    stmt                           shift and go to state 4
    expr                           shift and go to state 11
    term                           shift and go to state 17

state 1

    (0) S' -> program .


state 2

    (1) program -> stmt_set .
    (2) stmt_set -> stmt_set . block
    (3) stmt_set -> stmt_set . block ;
    (4) stmt_set -> stmt_set . stmt
    (5) stmt_set -> stmt_set . stmt ;
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    $end            reduce using rule 1 (program -> stmt_set .)
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    block                          shift and go to state 25
    stmt                           shift and go to state 26
    expr                           shift and go to state 11
    term                           shift and go to state 17

state 3

    (6) stmt_set -> block .
    (7) stmt_set -> block . ;
    {               reduce using rule 6 (stmt_set -> block .)
    RETURN          reduce using rule 6 (stmt_set -> block .)
    PRINT           reduce using rule 6 (stmt_set -> block .)
    CONTINUE        reduce using rule 6 (stmt_set -> block .)
    BREAK           reduce using rule 6 (stmt_set -> block .)
    ID              reduce using rule 6 (stmt_set -> block .)
    FOR             reduce using rule 6 (stmt_set -> block .)
    WHILE           reduce using rule 6 (stmt_set -> block .)
    IF              reduce using rule 6 (stmt_set -> block .)
    [               reduce using rule 6 (stmt_set -> block .)
    (               reduce using rule 6 (stmt_set -> block .)
    -               reduce using rule 6 (stmt_set -> block .)
    STRING          reduce using rule 6 (stmt_set -> block .)
    FLOATNUM        reduce using rule 6 (stmt_set -> block .)
    INTNUM          reduce using rule 6 (stmt_set -> block .)
    EYE             reduce using rule 6 (stmt_set -> block .)
    ONES            reduce using rule 6 (stmt_set -> block .)
    ZEROS           reduce using rule 6 (stmt_set -> block .)
    $end            reduce using rule 6 (stmt_set -> block .)
    }               reduce using rule 6 (stmt_set -> block .)
    ;               shift and go to state 27


state 4

    (8) stmt_set -> stmt .
    (9) stmt_set -> stmt . ;
    (24) block -> stmt . ;
    (25) block -> stmt .
  ! shift/reduce conflict for ; resolved as shift
  ! reduce/reduce conflict for { resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for RETURN resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for PRINT resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for BREAK resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for ID resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for FOR resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for WHILE resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for IF resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for [ resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for ( resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for - resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for STRING resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for INTNUM resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for EYE resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for ONES resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for ZEROS resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for $end resolved using rule 8 (stmt_set -> stmt .)
  ! reduce/reduce conflict for } resolved using rule 8 (stmt_set -> stmt .)
    {               reduce using rule 8 (stmt_set -> stmt .)
    RETURN          reduce using rule 8 (stmt_set -> stmt .)
    PRINT           reduce using rule 8 (stmt_set -> stmt .)
    CONTINUE        reduce using rule 8 (stmt_set -> stmt .)
    BREAK           reduce using rule 8 (stmt_set -> stmt .)
    ID              reduce using rule 8 (stmt_set -> stmt .)
    FOR             reduce using rule 8 (stmt_set -> stmt .)
    WHILE           reduce using rule 8 (stmt_set -> stmt .)
    IF              reduce using rule 8 (stmt_set -> stmt .)
    [               reduce using rule 8 (stmt_set -> stmt .)
    (               reduce using rule 8 (stmt_set -> stmt .)
    -               reduce using rule 8 (stmt_set -> stmt .)
    STRING          reduce using rule 8 (stmt_set -> stmt .)
    FLOATNUM        reduce using rule 8 (stmt_set -> stmt .)
    INTNUM          reduce using rule 8 (stmt_set -> stmt .)
    EYE             reduce using rule 8 (stmt_set -> stmt .)
    ONES            reduce using rule 8 (stmt_set -> stmt .)
    ZEROS           reduce using rule 8 (stmt_set -> stmt .)
    $end            reduce using rule 8 (stmt_set -> stmt .)
    }               reduce using rule 8 (stmt_set -> stmt .)
    ;               shift and go to state 28


state 5

    (26) block -> { . stmt_set }
    (2) stmt_set -> . stmt_set block
    (3) stmt_set -> . stmt_set block ;
    (4) stmt_set -> . stmt_set stmt
    (5) stmt_set -> . stmt_set stmt ;
    (6) stmt_set -> . block
    (7) stmt_set -> . block ;
    (8) stmt_set -> . stmt
    (9) stmt_set -> . stmt ;
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    stmt_set                       shift and go to state 29
    block                          shift and go to state 3
    stmt                           shift and go to state 4
    expr                           shift and go to state 11
    term                           shift and go to state 17

state 6

    (10) stmt -> RETURN . innerlist
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    innerlist                      shift and go to state 30
    expr                           shift and go to state 31
    term                           shift and go to state 17

state 7

    (11) stmt -> PRINT . innerlist
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    innerlist                      shift and go to state 33
    expr                           shift and go to state 31
    term                           shift and go to state 17

state 8

    (12) stmt -> CONTINUE .
    ;               reduce using rule 12 (stmt -> CONTINUE .)
    {               reduce using rule 12 (stmt -> CONTINUE .)
    RETURN          reduce using rule 12 (stmt -> CONTINUE .)
    PRINT           reduce using rule 12 (stmt -> CONTINUE .)
    CONTINUE        reduce using rule 12 (stmt -> CONTINUE .)
    BREAK           reduce using rule 12 (stmt -> CONTINUE .)
    ID              reduce using rule 12 (stmt -> CONTINUE .)
    FOR             reduce using rule 12 (stmt -> CONTINUE .)
    WHILE           reduce using rule 12 (stmt -> CONTINUE .)
    IF              reduce using rule 12 (stmt -> CONTINUE .)
    [               reduce using rule 12 (stmt -> CONTINUE .)
    (               reduce using rule 12 (stmt -> CONTINUE .)
    -               reduce using rule 12 (stmt -> CONTINUE .)
    STRING          reduce using rule 12 (stmt -> CONTINUE .)
    FLOATNUM        reduce using rule 12 (stmt -> CONTINUE .)
    INTNUM          reduce using rule 12 (stmt -> CONTINUE .)
    EYE             reduce using rule 12 (stmt -> CONTINUE .)
    ONES            reduce using rule 12 (stmt -> CONTINUE .)
    ZEROS           reduce using rule 12 (stmt -> CONTINUE .)
    $end            reduce using rule 12 (stmt -> CONTINUE .)
    }               reduce using rule 12 (stmt -> CONTINUE .)
    ELSE            reduce using rule 12 (stmt -> CONTINUE .)


state 9

    (13) stmt -> BREAK .
    ;               reduce using rule 13 (stmt -> BREAK .)
    {               reduce using rule 13 (stmt -> BREAK .)
    RETURN          reduce using rule 13 (stmt -> BREAK .)
    PRINT           reduce using rule 13 (stmt -> BREAK .)
    CONTINUE        reduce using rule 13 (stmt -> BREAK .)
    BREAK           reduce using rule 13 (stmt -> BREAK .)
    ID              reduce using rule 13 (stmt -> BREAK .)
    FOR             reduce using rule 13 (stmt -> BREAK .)
    WHILE           reduce using rule 13 (stmt -> BREAK .)
    IF              reduce using rule 13 (stmt -> BREAK .)
    [               reduce using rule 13 (stmt -> BREAK .)
    (               reduce using rule 13 (stmt -> BREAK .)
    -               reduce using rule 13 (stmt -> BREAK .)
    STRING          reduce using rule 13 (stmt -> BREAK .)
    FLOATNUM        reduce using rule 13 (stmt -> BREAK .)
    INTNUM          reduce using rule 13 (stmt -> BREAK .)
    EYE             reduce using rule 13 (stmt -> BREAK .)
    ONES            reduce using rule 13 (stmt -> BREAK .)
    ZEROS           reduce using rule 13 (stmt -> BREAK .)
    $end            reduce using rule 13 (stmt -> BREAK .)
    }               reduce using rule 13 (stmt -> BREAK .)
    ELSE            reduce using rule 13 (stmt -> BREAK .)


state 10

    (14) stmt -> ID . DIVASSIGN expr
    (15) stmt -> ID . MULASSIGN expr
    (16) stmt -> ID . SUBASSIGN expr
    (17) stmt -> ID . ADDASSIGN expr
    (51) term -> ID .
    DIVASSIGN       shift and go to state 34
    MULASSIGN       shift and go to state 35
    SUBASSIGN       shift and go to state 36
    ADDASSIGN       shift and go to state 37
    =               reduce using rule 51 (term -> ID .)
    [               reduce using rule 51 (term -> ID .)
    NEQ             reduce using rule 51 (term -> ID .)
    EQU             reduce using rule 51 (term -> ID .)
    GEQ             reduce using rule 51 (term -> ID .)
    LEQ             reduce using rule 51 (term -> ID .)
    >               reduce using rule 51 (term -> ID .)
    <               reduce using rule 51 (term -> ID .)
    '               reduce using rule 51 (term -> ID .)
    DOTDIV          reduce using rule 51 (term -> ID .)
    DOTMUL          reduce using rule 51 (term -> ID .)
    DOTSUB          reduce using rule 51 (term -> ID .)
    DOTADD          reduce using rule 51 (term -> ID .)
    /               reduce using rule 51 (term -> ID .)
    *               reduce using rule 51 (term -> ID .)
    -               reduce using rule 51 (term -> ID .)
    +               reduce using rule 51 (term -> ID .)
    ;               reduce using rule 51 (term -> ID .)
    {               reduce using rule 51 (term -> ID .)
    RETURN          reduce using rule 51 (term -> ID .)
    PRINT           reduce using rule 51 (term -> ID .)
    CONTINUE        reduce using rule 51 (term -> ID .)
    BREAK           reduce using rule 51 (term -> ID .)
    ID              reduce using rule 51 (term -> ID .)
    FOR             reduce using rule 51 (term -> ID .)
    WHILE           reduce using rule 51 (term -> ID .)
    IF              reduce using rule 51 (term -> ID .)
    (               reduce using rule 51 (term -> ID .)
    STRING          reduce using rule 51 (term -> ID .)
    FLOATNUM        reduce using rule 51 (term -> ID .)
    INTNUM          reduce using rule 51 (term -> ID .)
    EYE             reduce using rule 51 (term -> ID .)
    ONES            reduce using rule 51 (term -> ID .)
    ZEROS           reduce using rule 51 (term -> ID .)
    $end            reduce using rule 51 (term -> ID .)
    }               reduce using rule 51 (term -> ID .)
    ELSE            reduce using rule 51 (term -> ID .)


state 11

    (18) stmt -> expr . = expr
    (23) stmt -> expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for - resolved as shift
    =               shift and go to state 38
    ;               reduce using rule 23 (stmt -> expr .)
    {               reduce using rule 23 (stmt -> expr .)
    RETURN          reduce using rule 23 (stmt -> expr .)
    PRINT           reduce using rule 23 (stmt -> expr .)
    CONTINUE        reduce using rule 23 (stmt -> expr .)
    BREAK           reduce using rule 23 (stmt -> expr .)
    ID              reduce using rule 23 (stmt -> expr .)
    FOR             reduce using rule 23 (stmt -> expr .)
    WHILE           reduce using rule 23 (stmt -> expr .)
    IF              reduce using rule 23 (stmt -> expr .)
    (               reduce using rule 23 (stmt -> expr .)
    STRING          reduce using rule 23 (stmt -> expr .)
    FLOATNUM        reduce using rule 23 (stmt -> expr .)
    INTNUM          reduce using rule 23 (stmt -> expr .)
    EYE             reduce using rule 23 (stmt -> expr .)
    ONES            reduce using rule 23 (stmt -> expr .)
    ZEROS           reduce using rule 23 (stmt -> expr .)
    $end            reduce using rule 23 (stmt -> expr .)
    }               reduce using rule 23 (stmt -> expr .)
    ELSE            reduce using rule 23 (stmt -> expr .)
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 12

    (19) stmt -> FOR . ID = expr : expr block
    ID              shift and go to state 55


state 13

    (20) stmt -> WHILE . ( expr ) block
    (               shift and go to state 56


state 14

    (36) expr -> ( . expr )
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 57
    term                           shift and go to state 17

state 15

    (21) stmt -> IF . ( expr ) block
    (22) stmt -> IF . ( expr ) block ELSE block
    (               shift and go to state 58


state 16

    (28) expr -> [ . outerlist ]
    (47) outerlist -> . [ innerlist ]
    (48) outerlist -> . outerlist , [ innerlist ]
    [               shift and go to state 59

    outerlist                      shift and go to state 60

state 17

    (29) expr -> term .
    =               reduce using rule 29 (expr -> term .)
    [               reduce using rule 29 (expr -> term .)
    NEQ             reduce using rule 29 (expr -> term .)
    EQU             reduce using rule 29 (expr -> term .)
    GEQ             reduce using rule 29 (expr -> term .)
    LEQ             reduce using rule 29 (expr -> term .)
    >               reduce using rule 29 (expr -> term .)
    <               reduce using rule 29 (expr -> term .)
    '               reduce using rule 29 (expr -> term .)
    DOTDIV          reduce using rule 29 (expr -> term .)
    DOTMUL          reduce using rule 29 (expr -> term .)
    DOTSUB          reduce using rule 29 (expr -> term .)
    DOTADD          reduce using rule 29 (expr -> term .)
    /               reduce using rule 29 (expr -> term .)
    *               reduce using rule 29 (expr -> term .)
    -               reduce using rule 29 (expr -> term .)
    +               reduce using rule 29 (expr -> term .)
    ;               reduce using rule 29 (expr -> term .)
    {               reduce using rule 29 (expr -> term .)
    RETURN          reduce using rule 29 (expr -> term .)
    PRINT           reduce using rule 29 (expr -> term .)
    CONTINUE        reduce using rule 29 (expr -> term .)
    BREAK           reduce using rule 29 (expr -> term .)
    ID              reduce using rule 29 (expr -> term .)
    FOR             reduce using rule 29 (expr -> term .)
    WHILE           reduce using rule 29 (expr -> term .)
    IF              reduce using rule 29 (expr -> term .)
    (               reduce using rule 29 (expr -> term .)
    STRING          reduce using rule 29 (expr -> term .)
    FLOATNUM        reduce using rule 29 (expr -> term .)
    INTNUM          reduce using rule 29 (expr -> term .)
    EYE             reduce using rule 29 (expr -> term .)
    ONES            reduce using rule 29 (expr -> term .)
    ZEROS           reduce using rule 29 (expr -> term .)
    $end            reduce using rule 29 (expr -> term .)
    }               reduce using rule 29 (expr -> term .)
    ,               reduce using rule 29 (expr -> term .)
    ELSE            reduce using rule 29 (expr -> term .)
    )               reduce using rule 29 (expr -> term .)
    ]               reduce using rule 29 (expr -> term .)
    :               reduce using rule 29 (expr -> term .)


state 18

    (38) expr -> - . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 61
    term                           shift and go to state 17

state 19

    (52) term -> STRING .
    =               reduce using rule 52 (term -> STRING .)
    [               reduce using rule 52 (term -> STRING .)
    NEQ             reduce using rule 52 (term -> STRING .)
    EQU             reduce using rule 52 (term -> STRING .)
    GEQ             reduce using rule 52 (term -> STRING .)
    LEQ             reduce using rule 52 (term -> STRING .)
    >               reduce using rule 52 (term -> STRING .)
    <               reduce using rule 52 (term -> STRING .)
    '               reduce using rule 52 (term -> STRING .)
    DOTDIV          reduce using rule 52 (term -> STRING .)
    DOTMUL          reduce using rule 52 (term -> STRING .)
    DOTSUB          reduce using rule 52 (term -> STRING .)
    DOTADD          reduce using rule 52 (term -> STRING .)
    /               reduce using rule 52 (term -> STRING .)
    *               reduce using rule 52 (term -> STRING .)
    -               reduce using rule 52 (term -> STRING .)
    +               reduce using rule 52 (term -> STRING .)
    ;               reduce using rule 52 (term -> STRING .)
    {               reduce using rule 52 (term -> STRING .)
    RETURN          reduce using rule 52 (term -> STRING .)
    PRINT           reduce using rule 52 (term -> STRING .)
    CONTINUE        reduce using rule 52 (term -> STRING .)
    BREAK           reduce using rule 52 (term -> STRING .)
    ID              reduce using rule 52 (term -> STRING .)
    FOR             reduce using rule 52 (term -> STRING .)
    WHILE           reduce using rule 52 (term -> STRING .)
    IF              reduce using rule 52 (term -> STRING .)
    (               reduce using rule 52 (term -> STRING .)
    STRING          reduce using rule 52 (term -> STRING .)
    FLOATNUM        reduce using rule 52 (term -> STRING .)
    INTNUM          reduce using rule 52 (term -> STRING .)
    EYE             reduce using rule 52 (term -> STRING .)
    ONES            reduce using rule 52 (term -> STRING .)
    ZEROS           reduce using rule 52 (term -> STRING .)
    $end            reduce using rule 52 (term -> STRING .)
    }               reduce using rule 52 (term -> STRING .)
    ,               reduce using rule 52 (term -> STRING .)
    ELSE            reduce using rule 52 (term -> STRING .)
    )               reduce using rule 52 (term -> STRING .)
    ]               reduce using rule 52 (term -> STRING .)
    :               reduce using rule 52 (term -> STRING .)


state 20

    (53) term -> FLOATNUM .
    =               reduce using rule 53 (term -> FLOATNUM .)
    [               reduce using rule 53 (term -> FLOATNUM .)
    NEQ             reduce using rule 53 (term -> FLOATNUM .)
    EQU             reduce using rule 53 (term -> FLOATNUM .)
    GEQ             reduce using rule 53 (term -> FLOATNUM .)
    LEQ             reduce using rule 53 (term -> FLOATNUM .)
    >               reduce using rule 53 (term -> FLOATNUM .)
    <               reduce using rule 53 (term -> FLOATNUM .)
    '               reduce using rule 53 (term -> FLOATNUM .)
    DOTDIV          reduce using rule 53 (term -> FLOATNUM .)
    DOTMUL          reduce using rule 53 (term -> FLOATNUM .)
    DOTSUB          reduce using rule 53 (term -> FLOATNUM .)
    DOTADD          reduce using rule 53 (term -> FLOATNUM .)
    /               reduce using rule 53 (term -> FLOATNUM .)
    *               reduce using rule 53 (term -> FLOATNUM .)
    -               reduce using rule 53 (term -> FLOATNUM .)
    +               reduce using rule 53 (term -> FLOATNUM .)
    ;               reduce using rule 53 (term -> FLOATNUM .)
    {               reduce using rule 53 (term -> FLOATNUM .)
    RETURN          reduce using rule 53 (term -> FLOATNUM .)
    PRINT           reduce using rule 53 (term -> FLOATNUM .)
    CONTINUE        reduce using rule 53 (term -> FLOATNUM .)
    BREAK           reduce using rule 53 (term -> FLOATNUM .)
    ID              reduce using rule 53 (term -> FLOATNUM .)
    FOR             reduce using rule 53 (term -> FLOATNUM .)
    WHILE           reduce using rule 53 (term -> FLOATNUM .)
    IF              reduce using rule 53 (term -> FLOATNUM .)
    (               reduce using rule 53 (term -> FLOATNUM .)
    STRING          reduce using rule 53 (term -> FLOATNUM .)
    FLOATNUM        reduce using rule 53 (term -> FLOATNUM .)
    INTNUM          reduce using rule 53 (term -> FLOATNUM .)
    EYE             reduce using rule 53 (term -> FLOATNUM .)
    ONES            reduce using rule 53 (term -> FLOATNUM .)
    ZEROS           reduce using rule 53 (term -> FLOATNUM .)
    $end            reduce using rule 53 (term -> FLOATNUM .)
    }               reduce using rule 53 (term -> FLOATNUM .)
    ,               reduce using rule 53 (term -> FLOATNUM .)
    ELSE            reduce using rule 53 (term -> FLOATNUM .)
    )               reduce using rule 53 (term -> FLOATNUM .)
    ]               reduce using rule 53 (term -> FLOATNUM .)
    :               reduce using rule 53 (term -> FLOATNUM .)


state 21

    (54) term -> INTNUM .
    =               reduce using rule 54 (term -> INTNUM .)
    [               reduce using rule 54 (term -> INTNUM .)
    NEQ             reduce using rule 54 (term -> INTNUM .)
    EQU             reduce using rule 54 (term -> INTNUM .)
    GEQ             reduce using rule 54 (term -> INTNUM .)
    LEQ             reduce using rule 54 (term -> INTNUM .)
    >               reduce using rule 54 (term -> INTNUM .)
    <               reduce using rule 54 (term -> INTNUM .)
    '               reduce using rule 54 (term -> INTNUM .)
    DOTDIV          reduce using rule 54 (term -> INTNUM .)
    DOTMUL          reduce using rule 54 (term -> INTNUM .)
    DOTSUB          reduce using rule 54 (term -> INTNUM .)
    DOTADD          reduce using rule 54 (term -> INTNUM .)
    /               reduce using rule 54 (term -> INTNUM .)
    *               reduce using rule 54 (term -> INTNUM .)
    -               reduce using rule 54 (term -> INTNUM .)
    +               reduce using rule 54 (term -> INTNUM .)
    ;               reduce using rule 54 (term -> INTNUM .)
    {               reduce using rule 54 (term -> INTNUM .)
    RETURN          reduce using rule 54 (term -> INTNUM .)
    PRINT           reduce using rule 54 (term -> INTNUM .)
    CONTINUE        reduce using rule 54 (term -> INTNUM .)
    BREAK           reduce using rule 54 (term -> INTNUM .)
    ID              reduce using rule 54 (term -> INTNUM .)
    FOR             reduce using rule 54 (term -> INTNUM .)
    WHILE           reduce using rule 54 (term -> INTNUM .)
    IF              reduce using rule 54 (term -> INTNUM .)
    (               reduce using rule 54 (term -> INTNUM .)
    STRING          reduce using rule 54 (term -> INTNUM .)
    FLOATNUM        reduce using rule 54 (term -> INTNUM .)
    INTNUM          reduce using rule 54 (term -> INTNUM .)
    EYE             reduce using rule 54 (term -> INTNUM .)
    ONES            reduce using rule 54 (term -> INTNUM .)
    ZEROS           reduce using rule 54 (term -> INTNUM .)
    $end            reduce using rule 54 (term -> INTNUM .)
    }               reduce using rule 54 (term -> INTNUM .)
    ,               reduce using rule 54 (term -> INTNUM .)
    ELSE            reduce using rule 54 (term -> INTNUM .)
    )               reduce using rule 54 (term -> INTNUM .)
    ]               reduce using rule 54 (term -> INTNUM .)
    :               reduce using rule 54 (term -> INTNUM .)


state 22

    (55) term -> EYE . ( expr )
    (               shift and go to state 62


state 23

    (56) term -> ONES . ( expr )
    (               shift and go to state 63


state 24

    (57) term -> ZEROS . ( expr )
    (               shift and go to state 64


state 25

    (2) stmt_set -> stmt_set block .
    (3) stmt_set -> stmt_set block . ;
    {               reduce using rule 2 (stmt_set -> stmt_set block .)
    RETURN          reduce using rule 2 (stmt_set -> stmt_set block .)
    PRINT           reduce using rule 2 (stmt_set -> stmt_set block .)
    CONTINUE        reduce using rule 2 (stmt_set -> stmt_set block .)
    BREAK           reduce using rule 2 (stmt_set -> stmt_set block .)
    ID              reduce using rule 2 (stmt_set -> stmt_set block .)
    FOR             reduce using rule 2 (stmt_set -> stmt_set block .)
    WHILE           reduce using rule 2 (stmt_set -> stmt_set block .)
    IF              reduce using rule 2 (stmt_set -> stmt_set block .)
    [               reduce using rule 2 (stmt_set -> stmt_set block .)
    (               reduce using rule 2 (stmt_set -> stmt_set block .)
    -               reduce using rule 2 (stmt_set -> stmt_set block .)
    STRING          reduce using rule 2 (stmt_set -> stmt_set block .)
    FLOATNUM        reduce using rule 2 (stmt_set -> stmt_set block .)
    INTNUM          reduce using rule 2 (stmt_set -> stmt_set block .)
    EYE             reduce using rule 2 (stmt_set -> stmt_set block .)
    ONES            reduce using rule 2 (stmt_set -> stmt_set block .)
    ZEROS           reduce using rule 2 (stmt_set -> stmt_set block .)
    $end            reduce using rule 2 (stmt_set -> stmt_set block .)
    }               reduce using rule 2 (stmt_set -> stmt_set block .)
    ;               shift and go to state 65


state 26

    (4) stmt_set -> stmt_set stmt .
    (5) stmt_set -> stmt_set stmt . ;
    (24) block -> stmt . ;
    (25) block -> stmt .
  ! shift/reduce conflict for ; resolved as shift
  ! reduce/reduce conflict for { resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for RETURN resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for BREAK resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for ID resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for FOR resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for IF resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for [ resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for ( resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for - resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for STRING resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for INTNUM resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for EYE resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for ONES resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for ZEROS resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for $end resolved using rule 4 (stmt_set -> stmt_set stmt .)
  ! reduce/reduce conflict for } resolved using rule 4 (stmt_set -> stmt_set stmt .)
    {               reduce using rule 4 (stmt_set -> stmt_set stmt .)
    RETURN          reduce using rule 4 (stmt_set -> stmt_set stmt .)
    PRINT           reduce using rule 4 (stmt_set -> stmt_set stmt .)
    CONTINUE        reduce using rule 4 (stmt_set -> stmt_set stmt .)
    BREAK           reduce using rule 4 (stmt_set -> stmt_set stmt .)
    ID              reduce using rule 4 (stmt_set -> stmt_set stmt .)
    FOR             reduce using rule 4 (stmt_set -> stmt_set stmt .)
    WHILE           reduce using rule 4 (stmt_set -> stmt_set stmt .)
    IF              reduce using rule 4 (stmt_set -> stmt_set stmt .)
    [               reduce using rule 4 (stmt_set -> stmt_set stmt .)
    (               reduce using rule 4 (stmt_set -> stmt_set stmt .)
    -               reduce using rule 4 (stmt_set -> stmt_set stmt .)
    STRING          reduce using rule 4 (stmt_set -> stmt_set stmt .)
    FLOATNUM        reduce using rule 4 (stmt_set -> stmt_set stmt .)
    INTNUM          reduce using rule 4 (stmt_set -> stmt_set stmt .)
    EYE             reduce using rule 4 (stmt_set -> stmt_set stmt .)
    ONES            reduce using rule 4 (stmt_set -> stmt_set stmt .)
    ZEROS           reduce using rule 4 (stmt_set -> stmt_set stmt .)
    $end            reduce using rule 4 (stmt_set -> stmt_set stmt .)
    }               reduce using rule 4 (stmt_set -> stmt_set stmt .)
    ;               shift and go to state 66


state 27

    (7) stmt_set -> block ; .
    {               reduce using rule 7 (stmt_set -> block ; .)
    RETURN          reduce using rule 7 (stmt_set -> block ; .)
    PRINT           reduce using rule 7 (stmt_set -> block ; .)
    CONTINUE        reduce using rule 7 (stmt_set -> block ; .)
    BREAK           reduce using rule 7 (stmt_set -> block ; .)
    ID              reduce using rule 7 (stmt_set -> block ; .)
    FOR             reduce using rule 7 (stmt_set -> block ; .)
    WHILE           reduce using rule 7 (stmt_set -> block ; .)
    IF              reduce using rule 7 (stmt_set -> block ; .)
    [               reduce using rule 7 (stmt_set -> block ; .)
    (               reduce using rule 7 (stmt_set -> block ; .)
    -               reduce using rule 7 (stmt_set -> block ; .)
    STRING          reduce using rule 7 (stmt_set -> block ; .)
    FLOATNUM        reduce using rule 7 (stmt_set -> block ; .)
    INTNUM          reduce using rule 7 (stmt_set -> block ; .)
    EYE             reduce using rule 7 (stmt_set -> block ; .)
    ONES            reduce using rule 7 (stmt_set -> block ; .)
    ZEROS           reduce using rule 7 (stmt_set -> block ; .)
    $end            reduce using rule 7 (stmt_set -> block ; .)
    }               reduce using rule 7 (stmt_set -> block ; .)


state 28

    (9) stmt_set -> stmt ; .
    (24) block -> stmt ; .
  ! reduce/reduce conflict for { resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for RETURN resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for PRINT resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for BREAK resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for ID resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for FOR resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for WHILE resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for IF resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for [ resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for ( resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for - resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for STRING resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for INTNUM resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for EYE resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for ONES resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for ZEROS resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for $end resolved using rule 9 (stmt_set -> stmt ; .)
  ! reduce/reduce conflict for } resolved using rule 9 (stmt_set -> stmt ; .)
    {               reduce using rule 9 (stmt_set -> stmt ; .)
    RETURN          reduce using rule 9 (stmt_set -> stmt ; .)
    PRINT           reduce using rule 9 (stmt_set -> stmt ; .)
    CONTINUE        reduce using rule 9 (stmt_set -> stmt ; .)
    BREAK           reduce using rule 9 (stmt_set -> stmt ; .)
    ID              reduce using rule 9 (stmt_set -> stmt ; .)
    FOR             reduce using rule 9 (stmt_set -> stmt ; .)
    WHILE           reduce using rule 9 (stmt_set -> stmt ; .)
    IF              reduce using rule 9 (stmt_set -> stmt ; .)
    [               reduce using rule 9 (stmt_set -> stmt ; .)
    (               reduce using rule 9 (stmt_set -> stmt ; .)
    -               reduce using rule 9 (stmt_set -> stmt ; .)
    STRING          reduce using rule 9 (stmt_set -> stmt ; .)
    FLOATNUM        reduce using rule 9 (stmt_set -> stmt ; .)
    INTNUM          reduce using rule 9 (stmt_set -> stmt ; .)
    EYE             reduce using rule 9 (stmt_set -> stmt ; .)
    ONES            reduce using rule 9 (stmt_set -> stmt ; .)
    ZEROS           reduce using rule 9 (stmt_set -> stmt ; .)
    $end            reduce using rule 9 (stmt_set -> stmt ; .)
    }               reduce using rule 9 (stmt_set -> stmt ; .)
    ;               reduce using rule 24 (block -> stmt ; .)


state 29

    (26) block -> { stmt_set . }
    (2) stmt_set -> stmt_set . block
    (3) stmt_set -> stmt_set . block ;
    (4) stmt_set -> stmt_set . stmt
    (5) stmt_set -> stmt_set . stmt ;
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    }               shift and go to state 67
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    block                          shift and go to state 25
    stmt                           shift and go to state 26
    expr                           shift and go to state 11
    term                           shift and go to state 17

state 30

    (10) stmt -> RETURN innerlist .
    (50) innerlist -> innerlist . , expr
    ;               reduce using rule 10 (stmt -> RETURN innerlist .)
    {               reduce using rule 10 (stmt -> RETURN innerlist .)
    RETURN          reduce using rule 10 (stmt -> RETURN innerlist .)
    PRINT           reduce using rule 10 (stmt -> RETURN innerlist .)
    CONTINUE        reduce using rule 10 (stmt -> RETURN innerlist .)
    BREAK           reduce using rule 10 (stmt -> RETURN innerlist .)
    ID              reduce using rule 10 (stmt -> RETURN innerlist .)
    FOR             reduce using rule 10 (stmt -> RETURN innerlist .)
    WHILE           reduce using rule 10 (stmt -> RETURN innerlist .)
    IF              reduce using rule 10 (stmt -> RETURN innerlist .)
    [               reduce using rule 10 (stmt -> RETURN innerlist .)
    (               reduce using rule 10 (stmt -> RETURN innerlist .)
    -               reduce using rule 10 (stmt -> RETURN innerlist .)
    STRING          reduce using rule 10 (stmt -> RETURN innerlist .)
    FLOATNUM        reduce using rule 10 (stmt -> RETURN innerlist .)
    INTNUM          reduce using rule 10 (stmt -> RETURN innerlist .)
    EYE             reduce using rule 10 (stmt -> RETURN innerlist .)
    ONES            reduce using rule 10 (stmt -> RETURN innerlist .)
    ZEROS           reduce using rule 10 (stmt -> RETURN innerlist .)
    $end            reduce using rule 10 (stmt -> RETURN innerlist .)
    }               reduce using rule 10 (stmt -> RETURN innerlist .)
    ELSE            reduce using rule 10 (stmt -> RETURN innerlist .)
    ,               shift and go to state 68


state 31

    (49) innerlist -> expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 49 (innerlist -> expr .)
    ;               reduce using rule 49 (innerlist -> expr .)
    {               reduce using rule 49 (innerlist -> expr .)
    RETURN          reduce using rule 49 (innerlist -> expr .)
    PRINT           reduce using rule 49 (innerlist -> expr .)
    CONTINUE        reduce using rule 49 (innerlist -> expr .)
    BREAK           reduce using rule 49 (innerlist -> expr .)
    ID              reduce using rule 49 (innerlist -> expr .)
    FOR             reduce using rule 49 (innerlist -> expr .)
    WHILE           reduce using rule 49 (innerlist -> expr .)
    IF              reduce using rule 49 (innerlist -> expr .)
    (               reduce using rule 49 (innerlist -> expr .)
    STRING          reduce using rule 49 (innerlist -> expr .)
    FLOATNUM        reduce using rule 49 (innerlist -> expr .)
    INTNUM          reduce using rule 49 (innerlist -> expr .)
    EYE             reduce using rule 49 (innerlist -> expr .)
    ONES            reduce using rule 49 (innerlist -> expr .)
    ZEROS           reduce using rule 49 (innerlist -> expr .)
    $end            reduce using rule 49 (innerlist -> expr .)
    }               reduce using rule 49 (innerlist -> expr .)
    ELSE            reduce using rule 49 (innerlist -> expr .)
    ]               reduce using rule 49 (innerlist -> expr .)
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 32

    (51) term -> ID .
    [               reduce using rule 51 (term -> ID .)
    NEQ             reduce using rule 51 (term -> ID .)
    EQU             reduce using rule 51 (term -> ID .)
    GEQ             reduce using rule 51 (term -> ID .)
    LEQ             reduce using rule 51 (term -> ID .)
    >               reduce using rule 51 (term -> ID .)
    <               reduce using rule 51 (term -> ID .)
    '               reduce using rule 51 (term -> ID .)
    DOTDIV          reduce using rule 51 (term -> ID .)
    DOTMUL          reduce using rule 51 (term -> ID .)
    DOTSUB          reduce using rule 51 (term -> ID .)
    DOTADD          reduce using rule 51 (term -> ID .)
    /               reduce using rule 51 (term -> ID .)
    *               reduce using rule 51 (term -> ID .)
    -               reduce using rule 51 (term -> ID .)
    +               reduce using rule 51 (term -> ID .)
    ,               reduce using rule 51 (term -> ID .)
    ;               reduce using rule 51 (term -> ID .)
    {               reduce using rule 51 (term -> ID .)
    RETURN          reduce using rule 51 (term -> ID .)
    PRINT           reduce using rule 51 (term -> ID .)
    CONTINUE        reduce using rule 51 (term -> ID .)
    BREAK           reduce using rule 51 (term -> ID .)
    ID              reduce using rule 51 (term -> ID .)
    FOR             reduce using rule 51 (term -> ID .)
    WHILE           reduce using rule 51 (term -> ID .)
    IF              reduce using rule 51 (term -> ID .)
    (               reduce using rule 51 (term -> ID .)
    STRING          reduce using rule 51 (term -> ID .)
    FLOATNUM        reduce using rule 51 (term -> ID .)
    INTNUM          reduce using rule 51 (term -> ID .)
    EYE             reduce using rule 51 (term -> ID .)
    ONES            reduce using rule 51 (term -> ID .)
    ZEROS           reduce using rule 51 (term -> ID .)
    $end            reduce using rule 51 (term -> ID .)
    }               reduce using rule 51 (term -> ID .)
    ELSE            reduce using rule 51 (term -> ID .)
    )               reduce using rule 51 (term -> ID .)
    =               reduce using rule 51 (term -> ID .)
    ]               reduce using rule 51 (term -> ID .)
    :               reduce using rule 51 (term -> ID .)


state 33

    (11) stmt -> PRINT innerlist .
    (50) innerlist -> innerlist . , expr
    ;               reduce using rule 11 (stmt -> PRINT innerlist .)
    {               reduce using rule 11 (stmt -> PRINT innerlist .)
    RETURN          reduce using rule 11 (stmt -> PRINT innerlist .)
    PRINT           reduce using rule 11 (stmt -> PRINT innerlist .)
    CONTINUE        reduce using rule 11 (stmt -> PRINT innerlist .)
    BREAK           reduce using rule 11 (stmt -> PRINT innerlist .)
    ID              reduce using rule 11 (stmt -> PRINT innerlist .)
    FOR             reduce using rule 11 (stmt -> PRINT innerlist .)
    WHILE           reduce using rule 11 (stmt -> PRINT innerlist .)
    IF              reduce using rule 11 (stmt -> PRINT innerlist .)
    [               reduce using rule 11 (stmt -> PRINT innerlist .)
    (               reduce using rule 11 (stmt -> PRINT innerlist .)
    -               reduce using rule 11 (stmt -> PRINT innerlist .)
    STRING          reduce using rule 11 (stmt -> PRINT innerlist .)
    FLOATNUM        reduce using rule 11 (stmt -> PRINT innerlist .)
    INTNUM          reduce using rule 11 (stmt -> PRINT innerlist .)
    EYE             reduce using rule 11 (stmt -> PRINT innerlist .)
    ONES            reduce using rule 11 (stmt -> PRINT innerlist .)
    ZEROS           reduce using rule 11 (stmt -> PRINT innerlist .)
    $end            reduce using rule 11 (stmt -> PRINT innerlist .)
    }               reduce using rule 11 (stmt -> PRINT innerlist .)
    ELSE            reduce using rule 11 (stmt -> PRINT innerlist .)
    ,               shift and go to state 68


state 34

    (14) stmt -> ID DIVASSIGN . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 69
    term                           shift and go to state 17

state 35

    (15) stmt -> ID MULASSIGN . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 70
    term                           shift and go to state 17

state 36

    (16) stmt -> ID SUBASSIGN . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 71
    term                           shift and go to state 17

state 37

    (17) stmt -> ID ADDASSIGN . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 72
    term                           shift and go to state 17

state 38

    (18) stmt -> expr = . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 73
    term                           shift and go to state 17

state 39

    (27) expr -> expr [ . expr , expr ]
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 74
    term                           shift and go to state 17

state 40

    (30) expr -> expr NEQ . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 75
    term                           shift and go to state 17

state 41

    (31) expr -> expr EQU . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 76
    term                           shift and go to state 17

state 42

    (32) expr -> expr GEQ . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 77
    term                           shift and go to state 17

state 43

    (33) expr -> expr LEQ . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 78
    term                           shift and go to state 17

state 44

    (34) expr -> expr > . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 79
    term                           shift and go to state 17

state 45

    (35) expr -> expr < . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 80
    term                           shift and go to state 17

state 46

    (37) expr -> expr ' .
    =               reduce using rule 37 (expr -> expr ' .)
    [               reduce using rule 37 (expr -> expr ' .)
    NEQ             reduce using rule 37 (expr -> expr ' .)
    EQU             reduce using rule 37 (expr -> expr ' .)
    GEQ             reduce using rule 37 (expr -> expr ' .)
    LEQ             reduce using rule 37 (expr -> expr ' .)
    >               reduce using rule 37 (expr -> expr ' .)
    <               reduce using rule 37 (expr -> expr ' .)
    '               reduce using rule 37 (expr -> expr ' .)
    DOTDIV          reduce using rule 37 (expr -> expr ' .)
    DOTMUL          reduce using rule 37 (expr -> expr ' .)
    DOTSUB          reduce using rule 37 (expr -> expr ' .)
    DOTADD          reduce using rule 37 (expr -> expr ' .)
    /               reduce using rule 37 (expr -> expr ' .)
    *               reduce using rule 37 (expr -> expr ' .)
    -               reduce using rule 37 (expr -> expr ' .)
    +               reduce using rule 37 (expr -> expr ' .)
    ;               reduce using rule 37 (expr -> expr ' .)
    {               reduce using rule 37 (expr -> expr ' .)
    RETURN          reduce using rule 37 (expr -> expr ' .)
    PRINT           reduce using rule 37 (expr -> expr ' .)
    CONTINUE        reduce using rule 37 (expr -> expr ' .)
    BREAK           reduce using rule 37 (expr -> expr ' .)
    ID              reduce using rule 37 (expr -> expr ' .)
    FOR             reduce using rule 37 (expr -> expr ' .)
    WHILE           reduce using rule 37 (expr -> expr ' .)
    IF              reduce using rule 37 (expr -> expr ' .)
    (               reduce using rule 37 (expr -> expr ' .)
    STRING          reduce using rule 37 (expr -> expr ' .)
    FLOATNUM        reduce using rule 37 (expr -> expr ' .)
    INTNUM          reduce using rule 37 (expr -> expr ' .)
    EYE             reduce using rule 37 (expr -> expr ' .)
    ONES            reduce using rule 37 (expr -> expr ' .)
    ZEROS           reduce using rule 37 (expr -> expr ' .)
    $end            reduce using rule 37 (expr -> expr ' .)
    }               reduce using rule 37 (expr -> expr ' .)
    ,               reduce using rule 37 (expr -> expr ' .)
    ELSE            reduce using rule 37 (expr -> expr ' .)
    )               reduce using rule 37 (expr -> expr ' .)
    ]               reduce using rule 37 (expr -> expr ' .)
    :               reduce using rule 37 (expr -> expr ' .)


state 47

    (39) expr -> expr DOTDIV . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 81
    term                           shift and go to state 17

state 48

    (40) expr -> expr DOTMUL . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 82
    term                           shift and go to state 17

state 49

    (41) expr -> expr DOTSUB . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 83
    term                           shift and go to state 17

state 50

    (42) expr -> expr DOTADD . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 84
    term                           shift and go to state 17

state 51

    (43) expr -> expr / . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 85
    term                           shift and go to state 17

state 52

    (44) expr -> expr * . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 86
    term                           shift and go to state 17

state 53

    (45) expr -> expr - . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 87
    term                           shift and go to state 17

state 54

    (46) expr -> expr + . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 88
    term                           shift and go to state 17

state 55

    (19) stmt -> FOR ID . = expr : expr block
    =               shift and go to state 89


state 56

    (20) stmt -> WHILE ( . expr ) block
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 90
    term                           shift and go to state 17

state 57

    (36) expr -> ( expr . )
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 91
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 58

    (21) stmt -> IF ( . expr ) block
    (22) stmt -> IF ( . expr ) block ELSE block
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 92
    term                           shift and go to state 17

state 59

    (47) outerlist -> [ . innerlist ]
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    innerlist                      shift and go to state 93
    expr                           shift and go to state 31
    term                           shift and go to state 17

state 60

    (28) expr -> [ outerlist . ]
    (48) outerlist -> outerlist . , [ innerlist ]
    ]               shift and go to state 94
    ,               shift and go to state 95


state 61

    (38) expr -> - expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 38 (expr -> - expr .)
    [               reduce using rule 38 (expr -> - expr .)
    NEQ             reduce using rule 38 (expr -> - expr .)
    EQU             reduce using rule 38 (expr -> - expr .)
    GEQ             reduce using rule 38 (expr -> - expr .)
    LEQ             reduce using rule 38 (expr -> - expr .)
    >               reduce using rule 38 (expr -> - expr .)
    <               reduce using rule 38 (expr -> - expr .)
    DOTDIV          reduce using rule 38 (expr -> - expr .)
    DOTMUL          reduce using rule 38 (expr -> - expr .)
    DOTSUB          reduce using rule 38 (expr -> - expr .)
    DOTADD          reduce using rule 38 (expr -> - expr .)
    /               reduce using rule 38 (expr -> - expr .)
    *               reduce using rule 38 (expr -> - expr .)
    -               reduce using rule 38 (expr -> - expr .)
    +               reduce using rule 38 (expr -> - expr .)
    ;               reduce using rule 38 (expr -> - expr .)
    {               reduce using rule 38 (expr -> - expr .)
    RETURN          reduce using rule 38 (expr -> - expr .)
    PRINT           reduce using rule 38 (expr -> - expr .)
    CONTINUE        reduce using rule 38 (expr -> - expr .)
    BREAK           reduce using rule 38 (expr -> - expr .)
    ID              reduce using rule 38 (expr -> - expr .)
    FOR             reduce using rule 38 (expr -> - expr .)
    WHILE           reduce using rule 38 (expr -> - expr .)
    IF              reduce using rule 38 (expr -> - expr .)
    (               reduce using rule 38 (expr -> - expr .)
    STRING          reduce using rule 38 (expr -> - expr .)
    FLOATNUM        reduce using rule 38 (expr -> - expr .)
    INTNUM          reduce using rule 38 (expr -> - expr .)
    EYE             reduce using rule 38 (expr -> - expr .)
    ONES            reduce using rule 38 (expr -> - expr .)
    ZEROS           reduce using rule 38 (expr -> - expr .)
    $end            reduce using rule 38 (expr -> - expr .)
    }               reduce using rule 38 (expr -> - expr .)
    ,               reduce using rule 38 (expr -> - expr .)
    ELSE            reduce using rule 38 (expr -> - expr .)
    )               reduce using rule 38 (expr -> - expr .)
    ]               reduce using rule 38 (expr -> - expr .)
    :               reduce using rule 38 (expr -> - expr .)
    '               shift and go to state 46


state 62

    (55) term -> EYE ( . expr )
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 96
    term                           shift and go to state 17

state 63

    (56) term -> ONES ( . expr )
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 97
    term                           shift and go to state 17

state 64

    (57) term -> ZEROS ( . expr )
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 98
    term                           shift and go to state 17

state 65

    (3) stmt_set -> stmt_set block ; .
    {               reduce using rule 3 (stmt_set -> stmt_set block ; .)
    RETURN          reduce using rule 3 (stmt_set -> stmt_set block ; .)
    PRINT           reduce using rule 3 (stmt_set -> stmt_set block ; .)
    CONTINUE        reduce using rule 3 (stmt_set -> stmt_set block ; .)
    BREAK           reduce using rule 3 (stmt_set -> stmt_set block ; .)
    ID              reduce using rule 3 (stmt_set -> stmt_set block ; .)
    FOR             reduce using rule 3 (stmt_set -> stmt_set block ; .)
    WHILE           reduce using rule 3 (stmt_set -> stmt_set block ; .)
    IF              reduce using rule 3 (stmt_set -> stmt_set block ; .)
    [               reduce using rule 3 (stmt_set -> stmt_set block ; .)
    (               reduce using rule 3 (stmt_set -> stmt_set block ; .)
    -               reduce using rule 3 (stmt_set -> stmt_set block ; .)
    STRING          reduce using rule 3 (stmt_set -> stmt_set block ; .)
    FLOATNUM        reduce using rule 3 (stmt_set -> stmt_set block ; .)
    INTNUM          reduce using rule 3 (stmt_set -> stmt_set block ; .)
    EYE             reduce using rule 3 (stmt_set -> stmt_set block ; .)
    ONES            reduce using rule 3 (stmt_set -> stmt_set block ; .)
    ZEROS           reduce using rule 3 (stmt_set -> stmt_set block ; .)
    $end            reduce using rule 3 (stmt_set -> stmt_set block ; .)
    }               reduce using rule 3 (stmt_set -> stmt_set block ; .)


state 66

    (5) stmt_set -> stmt_set stmt ; .
    (24) block -> stmt ; .
  ! reduce/reduce conflict for { resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for BREAK resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for ID resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for FOR resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for WHILE resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for IF resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for [ resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for ( resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for - resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for STRING resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for INTNUM resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for EYE resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for ONES resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for ZEROS resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for $end resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
  ! reduce/reduce conflict for } resolved using rule 5 (stmt_set -> stmt_set stmt ; .)
    {               reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    RETURN          reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    PRINT           reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    CONTINUE        reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    BREAK           reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    ID              reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    FOR             reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    WHILE           reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    IF              reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    [               reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    (               reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    -               reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    STRING          reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    FLOATNUM        reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    INTNUM          reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    EYE             reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    ONES            reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    ZEROS           reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    $end            reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    }               reduce using rule 5 (stmt_set -> stmt_set stmt ; .)
    ;               reduce using rule 24 (block -> stmt ; .)


state 67

    (26) block -> { stmt_set } .
    ;               reduce using rule 26 (block -> { stmt_set } .)
    {               reduce using rule 26 (block -> { stmt_set } .)
    RETURN          reduce using rule 26 (block -> { stmt_set } .)
    PRINT           reduce using rule 26 (block -> { stmt_set } .)
    CONTINUE        reduce using rule 26 (block -> { stmt_set } .)
    BREAK           reduce using rule 26 (block -> { stmt_set } .)
    ID              reduce using rule 26 (block -> { stmt_set } .)
    FOR             reduce using rule 26 (block -> { stmt_set } .)
    WHILE           reduce using rule 26 (block -> { stmt_set } .)
    IF              reduce using rule 26 (block -> { stmt_set } .)
    [               reduce using rule 26 (block -> { stmt_set } .)
    (               reduce using rule 26 (block -> { stmt_set } .)
    -               reduce using rule 26 (block -> { stmt_set } .)
    STRING          reduce using rule 26 (block -> { stmt_set } .)
    FLOATNUM        reduce using rule 26 (block -> { stmt_set } .)
    INTNUM          reduce using rule 26 (block -> { stmt_set } .)
    EYE             reduce using rule 26 (block -> { stmt_set } .)
    ONES            reduce using rule 26 (block -> { stmt_set } .)
    ZEROS           reduce using rule 26 (block -> { stmt_set } .)
    $end            reduce using rule 26 (block -> { stmt_set } .)
    }               reduce using rule 26 (block -> { stmt_set } .)
    ELSE            reduce using rule 26 (block -> { stmt_set } .)


state 68

    (50) innerlist -> innerlist , . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 99
    term                           shift and go to state 17

state 69

    (14) stmt -> ID DIVASSIGN expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ;               reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    {               reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    RETURN          reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    PRINT           reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    CONTINUE        reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    BREAK           reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    ID              reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    FOR             reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    WHILE           reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    IF              reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    [               reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    (               reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    STRING          reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    FLOATNUM        reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    INTNUM          reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    EYE             reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    ONES            reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    ZEROS           reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    $end            reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    }               reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    ELSE            reduce using rule 14 (stmt -> ID DIVASSIGN expr .)
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 70

    (15) stmt -> ID MULASSIGN expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ;               reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    {               reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    RETURN          reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    PRINT           reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    CONTINUE        reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    BREAK           reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    ID              reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    FOR             reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    WHILE           reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    IF              reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    [               reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    (               reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    STRING          reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    FLOATNUM        reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    INTNUM          reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    EYE             reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    ONES            reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    ZEROS           reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    $end            reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    }               reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    ELSE            reduce using rule 15 (stmt -> ID MULASSIGN expr .)
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 71

    (16) stmt -> ID SUBASSIGN expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ;               reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    {               reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    RETURN          reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    PRINT           reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    CONTINUE        reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    BREAK           reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    ID              reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    FOR             reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    WHILE           reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    IF              reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    [               reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    (               reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    STRING          reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    FLOATNUM        reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    INTNUM          reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    EYE             reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    ONES            reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    ZEROS           reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    $end            reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    }               reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    ELSE            reduce using rule 16 (stmt -> ID SUBASSIGN expr .)
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 72

    (17) stmt -> ID ADDASSIGN expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ;               reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    {               reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    RETURN          reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    PRINT           reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    CONTINUE        reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    BREAK           reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    ID              reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    FOR             reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    WHILE           reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    IF              reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    [               reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    (               reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    STRING          reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    FLOATNUM        reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    INTNUM          reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    EYE             reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    ONES            reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    ZEROS           reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    $end            reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    }               reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    ELSE            reduce using rule 17 (stmt -> ID ADDASSIGN expr .)
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 73

    (18) stmt -> expr = expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ;               reduce using rule 18 (stmt -> expr = expr .)
    {               reduce using rule 18 (stmt -> expr = expr .)
    RETURN          reduce using rule 18 (stmt -> expr = expr .)
    PRINT           reduce using rule 18 (stmt -> expr = expr .)
    CONTINUE        reduce using rule 18 (stmt -> expr = expr .)
    BREAK           reduce using rule 18 (stmt -> expr = expr .)
    ID              reduce using rule 18 (stmt -> expr = expr .)
    FOR             reduce using rule 18 (stmt -> expr = expr .)
    WHILE           reduce using rule 18 (stmt -> expr = expr .)
    IF              reduce using rule 18 (stmt -> expr = expr .)
    [               reduce using rule 18 (stmt -> expr = expr .)
    (               reduce using rule 18 (stmt -> expr = expr .)
    STRING          reduce using rule 18 (stmt -> expr = expr .)
    FLOATNUM        reduce using rule 18 (stmt -> expr = expr .)
    INTNUM          reduce using rule 18 (stmt -> expr = expr .)
    EYE             reduce using rule 18 (stmt -> expr = expr .)
    ONES            reduce using rule 18 (stmt -> expr = expr .)
    ZEROS           reduce using rule 18 (stmt -> expr = expr .)
    $end            reduce using rule 18 (stmt -> expr = expr .)
    }               reduce using rule 18 (stmt -> expr = expr .)
    ELSE            reduce using rule 18 (stmt -> expr = expr .)
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 74

    (27) expr -> expr [ expr . , expr ]
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ,               shift and go to state 100
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 75

    (30) expr -> expr NEQ expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 30 (expr -> expr NEQ expr .)
    [               reduce using rule 30 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 30 (expr -> expr NEQ expr .)
    EQU             reduce using rule 30 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 30 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 30 (expr -> expr NEQ expr .)
    >               reduce using rule 30 (expr -> expr NEQ expr .)
    <               reduce using rule 30 (expr -> expr NEQ expr .)
    ;               reduce using rule 30 (expr -> expr NEQ expr .)
    {               reduce using rule 30 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 30 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 30 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 30 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 30 (expr -> expr NEQ expr .)
    ID              reduce using rule 30 (expr -> expr NEQ expr .)
    FOR             reduce using rule 30 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 30 (expr -> expr NEQ expr .)
    IF              reduce using rule 30 (expr -> expr NEQ expr .)
    (               reduce using rule 30 (expr -> expr NEQ expr .)
    STRING          reduce using rule 30 (expr -> expr NEQ expr .)
    FLOATNUM        reduce using rule 30 (expr -> expr NEQ expr .)
    INTNUM          reduce using rule 30 (expr -> expr NEQ expr .)
    EYE             reduce using rule 30 (expr -> expr NEQ expr .)
    ONES            reduce using rule 30 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 30 (expr -> expr NEQ expr .)
    $end            reduce using rule 30 (expr -> expr NEQ expr .)
    }               reduce using rule 30 (expr -> expr NEQ expr .)
    ,               reduce using rule 30 (expr -> expr NEQ expr .)
    ELSE            reduce using rule 30 (expr -> expr NEQ expr .)
    )               reduce using rule 30 (expr -> expr NEQ expr .)
    ]               reduce using rule 30 (expr -> expr NEQ expr .)
    :               reduce using rule 30 (expr -> expr NEQ expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 76

    (31) expr -> expr EQU expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 31 (expr -> expr EQU expr .)
    [               reduce using rule 31 (expr -> expr EQU expr .)
    NEQ             reduce using rule 31 (expr -> expr EQU expr .)
    EQU             reduce using rule 31 (expr -> expr EQU expr .)
    GEQ             reduce using rule 31 (expr -> expr EQU expr .)
    LEQ             reduce using rule 31 (expr -> expr EQU expr .)
    >               reduce using rule 31 (expr -> expr EQU expr .)
    <               reduce using rule 31 (expr -> expr EQU expr .)
    ;               reduce using rule 31 (expr -> expr EQU expr .)
    {               reduce using rule 31 (expr -> expr EQU expr .)
    RETURN          reduce using rule 31 (expr -> expr EQU expr .)
    PRINT           reduce using rule 31 (expr -> expr EQU expr .)
    CONTINUE        reduce using rule 31 (expr -> expr EQU expr .)
    BREAK           reduce using rule 31 (expr -> expr EQU expr .)
    ID              reduce using rule 31 (expr -> expr EQU expr .)
    FOR             reduce using rule 31 (expr -> expr EQU expr .)
    WHILE           reduce using rule 31 (expr -> expr EQU expr .)
    IF              reduce using rule 31 (expr -> expr EQU expr .)
    (               reduce using rule 31 (expr -> expr EQU expr .)
    STRING          reduce using rule 31 (expr -> expr EQU expr .)
    FLOATNUM        reduce using rule 31 (expr -> expr EQU expr .)
    INTNUM          reduce using rule 31 (expr -> expr EQU expr .)
    EYE             reduce using rule 31 (expr -> expr EQU expr .)
    ONES            reduce using rule 31 (expr -> expr EQU expr .)
    ZEROS           reduce using rule 31 (expr -> expr EQU expr .)
    $end            reduce using rule 31 (expr -> expr EQU expr .)
    }               reduce using rule 31 (expr -> expr EQU expr .)
    ,               reduce using rule 31 (expr -> expr EQU expr .)
    ELSE            reduce using rule 31 (expr -> expr EQU expr .)
    )               reduce using rule 31 (expr -> expr EQU expr .)
    ]               reduce using rule 31 (expr -> expr EQU expr .)
    :               reduce using rule 31 (expr -> expr EQU expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 77

    (32) expr -> expr GEQ expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 32 (expr -> expr GEQ expr .)
    [               reduce using rule 32 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    EQU             reduce using rule 32 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    >               reduce using rule 32 (expr -> expr GEQ expr .)
    <               reduce using rule 32 (expr -> expr GEQ expr .)
    ;               reduce using rule 32 (expr -> expr GEQ expr .)
    {               reduce using rule 32 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 32 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 32 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 32 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 32 (expr -> expr GEQ expr .)
    ID              reduce using rule 32 (expr -> expr GEQ expr .)
    FOR             reduce using rule 32 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 32 (expr -> expr GEQ expr .)
    IF              reduce using rule 32 (expr -> expr GEQ expr .)
    (               reduce using rule 32 (expr -> expr GEQ expr .)
    STRING          reduce using rule 32 (expr -> expr GEQ expr .)
    FLOATNUM        reduce using rule 32 (expr -> expr GEQ expr .)
    INTNUM          reduce using rule 32 (expr -> expr GEQ expr .)
    EYE             reduce using rule 32 (expr -> expr GEQ expr .)
    ONES            reduce using rule 32 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 32 (expr -> expr GEQ expr .)
    $end            reduce using rule 32 (expr -> expr GEQ expr .)
    }               reduce using rule 32 (expr -> expr GEQ expr .)
    ,               reduce using rule 32 (expr -> expr GEQ expr .)
    ELSE            reduce using rule 32 (expr -> expr GEQ expr .)
    )               reduce using rule 32 (expr -> expr GEQ expr .)
    ]               reduce using rule 32 (expr -> expr GEQ expr .)
    :               reduce using rule 32 (expr -> expr GEQ expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 78

    (33) expr -> expr LEQ expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 33 (expr -> expr LEQ expr .)
    [               reduce using rule 33 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    EQU             reduce using rule 33 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    >               reduce using rule 33 (expr -> expr LEQ expr .)
    <               reduce using rule 33 (expr -> expr LEQ expr .)
    ;               reduce using rule 33 (expr -> expr LEQ expr .)
    {               reduce using rule 33 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 33 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 33 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 33 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 33 (expr -> expr LEQ expr .)
    ID              reduce using rule 33 (expr -> expr LEQ expr .)
    FOR             reduce using rule 33 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 33 (expr -> expr LEQ expr .)
    IF              reduce using rule 33 (expr -> expr LEQ expr .)
    (               reduce using rule 33 (expr -> expr LEQ expr .)
    STRING          reduce using rule 33 (expr -> expr LEQ expr .)
    FLOATNUM        reduce using rule 33 (expr -> expr LEQ expr .)
    INTNUM          reduce using rule 33 (expr -> expr LEQ expr .)
    EYE             reduce using rule 33 (expr -> expr LEQ expr .)
    ONES            reduce using rule 33 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 33 (expr -> expr LEQ expr .)
    $end            reduce using rule 33 (expr -> expr LEQ expr .)
    }               reduce using rule 33 (expr -> expr LEQ expr .)
    ,               reduce using rule 33 (expr -> expr LEQ expr .)
    ELSE            reduce using rule 33 (expr -> expr LEQ expr .)
    )               reduce using rule 33 (expr -> expr LEQ expr .)
    ]               reduce using rule 33 (expr -> expr LEQ expr .)
    :               reduce using rule 33 (expr -> expr LEQ expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 79

    (34) expr -> expr > expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 34 (expr -> expr > expr .)
    [               reduce using rule 34 (expr -> expr > expr .)
    NEQ             reduce using rule 34 (expr -> expr > expr .)
    EQU             reduce using rule 34 (expr -> expr > expr .)
    GEQ             reduce using rule 34 (expr -> expr > expr .)
    LEQ             reduce using rule 34 (expr -> expr > expr .)
    >               reduce using rule 34 (expr -> expr > expr .)
    <               reduce using rule 34 (expr -> expr > expr .)
    ;               reduce using rule 34 (expr -> expr > expr .)
    {               reduce using rule 34 (expr -> expr > expr .)
    RETURN          reduce using rule 34 (expr -> expr > expr .)
    PRINT           reduce using rule 34 (expr -> expr > expr .)
    CONTINUE        reduce using rule 34 (expr -> expr > expr .)
    BREAK           reduce using rule 34 (expr -> expr > expr .)
    ID              reduce using rule 34 (expr -> expr > expr .)
    FOR             reduce using rule 34 (expr -> expr > expr .)
    WHILE           reduce using rule 34 (expr -> expr > expr .)
    IF              reduce using rule 34 (expr -> expr > expr .)
    (               reduce using rule 34 (expr -> expr > expr .)
    STRING          reduce using rule 34 (expr -> expr > expr .)
    FLOATNUM        reduce using rule 34 (expr -> expr > expr .)
    INTNUM          reduce using rule 34 (expr -> expr > expr .)
    EYE             reduce using rule 34 (expr -> expr > expr .)
    ONES            reduce using rule 34 (expr -> expr > expr .)
    ZEROS           reduce using rule 34 (expr -> expr > expr .)
    $end            reduce using rule 34 (expr -> expr > expr .)
    }               reduce using rule 34 (expr -> expr > expr .)
    ,               reduce using rule 34 (expr -> expr > expr .)
    ELSE            reduce using rule 34 (expr -> expr > expr .)
    )               reduce using rule 34 (expr -> expr > expr .)
    ]               reduce using rule 34 (expr -> expr > expr .)
    :               reduce using rule 34 (expr -> expr > expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 80

    (35) expr -> expr < expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 35 (expr -> expr < expr .)
    [               reduce using rule 35 (expr -> expr < expr .)
    NEQ             reduce using rule 35 (expr -> expr < expr .)
    EQU             reduce using rule 35 (expr -> expr < expr .)
    GEQ             reduce using rule 35 (expr -> expr < expr .)
    LEQ             reduce using rule 35 (expr -> expr < expr .)
    >               reduce using rule 35 (expr -> expr < expr .)
    <               reduce using rule 35 (expr -> expr < expr .)
    ;               reduce using rule 35 (expr -> expr < expr .)
    {               reduce using rule 35 (expr -> expr < expr .)
    RETURN          reduce using rule 35 (expr -> expr < expr .)
    PRINT           reduce using rule 35 (expr -> expr < expr .)
    CONTINUE        reduce using rule 35 (expr -> expr < expr .)
    BREAK           reduce using rule 35 (expr -> expr < expr .)
    ID              reduce using rule 35 (expr -> expr < expr .)
    FOR             reduce using rule 35 (expr -> expr < expr .)
    WHILE           reduce using rule 35 (expr -> expr < expr .)
    IF              reduce using rule 35 (expr -> expr < expr .)
    (               reduce using rule 35 (expr -> expr < expr .)
    STRING          reduce using rule 35 (expr -> expr < expr .)
    FLOATNUM        reduce using rule 35 (expr -> expr < expr .)
    INTNUM          reduce using rule 35 (expr -> expr < expr .)
    EYE             reduce using rule 35 (expr -> expr < expr .)
    ONES            reduce using rule 35 (expr -> expr < expr .)
    ZEROS           reduce using rule 35 (expr -> expr < expr .)
    $end            reduce using rule 35 (expr -> expr < expr .)
    }               reduce using rule 35 (expr -> expr < expr .)
    ,               reduce using rule 35 (expr -> expr < expr .)
    ELSE            reduce using rule 35 (expr -> expr < expr .)
    )               reduce using rule 35 (expr -> expr < expr .)
    ]               reduce using rule 35 (expr -> expr < expr .)
    :               reduce using rule 35 (expr -> expr < expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 81

    (39) expr -> expr DOTDIV expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 39 (expr -> expr DOTDIV expr .)
    [               reduce using rule 39 (expr -> expr DOTDIV expr .)
    NEQ             reduce using rule 39 (expr -> expr DOTDIV expr .)
    EQU             reduce using rule 39 (expr -> expr DOTDIV expr .)
    GEQ             reduce using rule 39 (expr -> expr DOTDIV expr .)
    LEQ             reduce using rule 39 (expr -> expr DOTDIV expr .)
    >               reduce using rule 39 (expr -> expr DOTDIV expr .)
    <               reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 39 (expr -> expr DOTDIV expr .)
    /               reduce using rule 39 (expr -> expr DOTDIV expr .)
    *               reduce using rule 39 (expr -> expr DOTDIV expr .)
    -               reduce using rule 39 (expr -> expr DOTDIV expr .)
    +               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 39 (expr -> expr DOTDIV expr .)
    {               reduce using rule 39 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 39 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 39 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 39 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 39 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 39 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 39 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 39 (expr -> expr DOTDIV expr .)
    (               reduce using rule 39 (expr -> expr DOTDIV expr .)
    STRING          reduce using rule 39 (expr -> expr DOTDIV expr .)
    FLOATNUM        reduce using rule 39 (expr -> expr DOTDIV expr .)
    INTNUM          reduce using rule 39 (expr -> expr DOTDIV expr .)
    EYE             reduce using rule 39 (expr -> expr DOTDIV expr .)
    ONES            reduce using rule 39 (expr -> expr DOTDIV expr .)
    ZEROS           reduce using rule 39 (expr -> expr DOTDIV expr .)
    $end            reduce using rule 39 (expr -> expr DOTDIV expr .)
    }               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ,               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ELSE            reduce using rule 39 (expr -> expr DOTDIV expr .)
    )               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 39 (expr -> expr DOTDIV expr .)
    :               reduce using rule 39 (expr -> expr DOTDIV expr .)
    '               shift and go to state 46


state 82

    (40) expr -> expr DOTMUL expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 40 (expr -> expr DOTMUL expr .)
    [               reduce using rule 40 (expr -> expr DOTMUL expr .)
    NEQ             reduce using rule 40 (expr -> expr DOTMUL expr .)
    EQU             reduce using rule 40 (expr -> expr DOTMUL expr .)
    GEQ             reduce using rule 40 (expr -> expr DOTMUL expr .)
    LEQ             reduce using rule 40 (expr -> expr DOTMUL expr .)
    >               reduce using rule 40 (expr -> expr DOTMUL expr .)
    <               reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 40 (expr -> expr DOTMUL expr .)
    /               reduce using rule 40 (expr -> expr DOTMUL expr .)
    *               reduce using rule 40 (expr -> expr DOTMUL expr .)
    -               reduce using rule 40 (expr -> expr DOTMUL expr .)
    +               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 40 (expr -> expr DOTMUL expr .)
    {               reduce using rule 40 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 40 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 40 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 40 (expr -> expr DOTMUL expr .)
    (               reduce using rule 40 (expr -> expr DOTMUL expr .)
    STRING          reduce using rule 40 (expr -> expr DOTMUL expr .)
    FLOATNUM        reduce using rule 40 (expr -> expr DOTMUL expr .)
    INTNUM          reduce using rule 40 (expr -> expr DOTMUL expr .)
    EYE             reduce using rule 40 (expr -> expr DOTMUL expr .)
    ONES            reduce using rule 40 (expr -> expr DOTMUL expr .)
    ZEROS           reduce using rule 40 (expr -> expr DOTMUL expr .)
    $end            reduce using rule 40 (expr -> expr DOTMUL expr .)
    }               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ,               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ELSE            reduce using rule 40 (expr -> expr DOTMUL expr .)
    )               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 40 (expr -> expr DOTMUL expr .)
    :               reduce using rule 40 (expr -> expr DOTMUL expr .)
    '               shift and go to state 46


state 83

    (41) expr -> expr DOTSUB expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 41 (expr -> expr DOTSUB expr .)
    [               reduce using rule 41 (expr -> expr DOTSUB expr .)
    NEQ             reduce using rule 41 (expr -> expr DOTSUB expr .)
    EQU             reduce using rule 41 (expr -> expr DOTSUB expr .)
    GEQ             reduce using rule 41 (expr -> expr DOTSUB expr .)
    LEQ             reduce using rule 41 (expr -> expr DOTSUB expr .)
    >               reduce using rule 41 (expr -> expr DOTSUB expr .)
    <               reduce using rule 41 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 41 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 41 (expr -> expr DOTSUB expr .)
    -               reduce using rule 41 (expr -> expr DOTSUB expr .)
    +               reduce using rule 41 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 41 (expr -> expr DOTSUB expr .)
    {               reduce using rule 41 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 41 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 41 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 41 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 41 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 41 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 41 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 41 (expr -> expr DOTSUB expr .)
    (               reduce using rule 41 (expr -> expr DOTSUB expr .)
    STRING          reduce using rule 41 (expr -> expr DOTSUB expr .)
    FLOATNUM        reduce using rule 41 (expr -> expr DOTSUB expr .)
    INTNUM          reduce using rule 41 (expr -> expr DOTSUB expr .)
    EYE             reduce using rule 41 (expr -> expr DOTSUB expr .)
    ONES            reduce using rule 41 (expr -> expr DOTSUB expr .)
    ZEROS           reduce using rule 41 (expr -> expr DOTSUB expr .)
    $end            reduce using rule 41 (expr -> expr DOTSUB expr .)
    }               reduce using rule 41 (expr -> expr DOTSUB expr .)
    ,               reduce using rule 41 (expr -> expr DOTSUB expr .)
    ELSE            reduce using rule 41 (expr -> expr DOTSUB expr .)
    )               reduce using rule 41 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 41 (expr -> expr DOTSUB expr .)
    :               reduce using rule 41 (expr -> expr DOTSUB expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    /               shift and go to state 51
    *               shift and go to state 52


state 84

    (42) expr -> expr DOTADD expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 42 (expr -> expr DOTADD expr .)
    [               reduce using rule 42 (expr -> expr DOTADD expr .)
    NEQ             reduce using rule 42 (expr -> expr DOTADD expr .)
    EQU             reduce using rule 42 (expr -> expr DOTADD expr .)
    GEQ             reduce using rule 42 (expr -> expr DOTADD expr .)
    LEQ             reduce using rule 42 (expr -> expr DOTADD expr .)
    >               reduce using rule 42 (expr -> expr DOTADD expr .)
    <               reduce using rule 42 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 42 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 42 (expr -> expr DOTADD expr .)
    -               reduce using rule 42 (expr -> expr DOTADD expr .)
    +               reduce using rule 42 (expr -> expr DOTADD expr .)
    ;               reduce using rule 42 (expr -> expr DOTADD expr .)
    {               reduce using rule 42 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 42 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 42 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 42 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 42 (expr -> expr DOTADD expr .)
    ID              reduce using rule 42 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 42 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 42 (expr -> expr DOTADD expr .)
    IF              reduce using rule 42 (expr -> expr DOTADD expr .)
    (               reduce using rule 42 (expr -> expr DOTADD expr .)
    STRING          reduce using rule 42 (expr -> expr DOTADD expr .)
    FLOATNUM        reduce using rule 42 (expr -> expr DOTADD expr .)
    INTNUM          reduce using rule 42 (expr -> expr DOTADD expr .)
    EYE             reduce using rule 42 (expr -> expr DOTADD expr .)
    ONES            reduce using rule 42 (expr -> expr DOTADD expr .)
    ZEROS           reduce using rule 42 (expr -> expr DOTADD expr .)
    $end            reduce using rule 42 (expr -> expr DOTADD expr .)
    }               reduce using rule 42 (expr -> expr DOTADD expr .)
    ,               reduce using rule 42 (expr -> expr DOTADD expr .)
    ELSE            reduce using rule 42 (expr -> expr DOTADD expr .)
    )               reduce using rule 42 (expr -> expr DOTADD expr .)
    ]               reduce using rule 42 (expr -> expr DOTADD expr .)
    :               reduce using rule 42 (expr -> expr DOTADD expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    /               shift and go to state 51
    *               shift and go to state 52


state 85

    (43) expr -> expr / expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 43 (expr -> expr / expr .)
    [               reduce using rule 43 (expr -> expr / expr .)
    NEQ             reduce using rule 43 (expr -> expr / expr .)
    EQU             reduce using rule 43 (expr -> expr / expr .)
    GEQ             reduce using rule 43 (expr -> expr / expr .)
    LEQ             reduce using rule 43 (expr -> expr / expr .)
    >               reduce using rule 43 (expr -> expr / expr .)
    <               reduce using rule 43 (expr -> expr / expr .)
    DOTDIV          reduce using rule 43 (expr -> expr / expr .)
    DOTMUL          reduce using rule 43 (expr -> expr / expr .)
    DOTSUB          reduce using rule 43 (expr -> expr / expr .)
    DOTADD          reduce using rule 43 (expr -> expr / expr .)
    /               reduce using rule 43 (expr -> expr / expr .)
    *               reduce using rule 43 (expr -> expr / expr .)
    -               reduce using rule 43 (expr -> expr / expr .)
    +               reduce using rule 43 (expr -> expr / expr .)
    ;               reduce using rule 43 (expr -> expr / expr .)
    {               reduce using rule 43 (expr -> expr / expr .)
    RETURN          reduce using rule 43 (expr -> expr / expr .)
    PRINT           reduce using rule 43 (expr -> expr / expr .)
    CONTINUE        reduce using rule 43 (expr -> expr / expr .)
    BREAK           reduce using rule 43 (expr -> expr / expr .)
    ID              reduce using rule 43 (expr -> expr / expr .)
    FOR             reduce using rule 43 (expr -> expr / expr .)
    WHILE           reduce using rule 43 (expr -> expr / expr .)
    IF              reduce using rule 43 (expr -> expr / expr .)
    (               reduce using rule 43 (expr -> expr / expr .)
    STRING          reduce using rule 43 (expr -> expr / expr .)
    FLOATNUM        reduce using rule 43 (expr -> expr / expr .)
    INTNUM          reduce using rule 43 (expr -> expr / expr .)
    EYE             reduce using rule 43 (expr -> expr / expr .)
    ONES            reduce using rule 43 (expr -> expr / expr .)
    ZEROS           reduce using rule 43 (expr -> expr / expr .)
    $end            reduce using rule 43 (expr -> expr / expr .)
    }               reduce using rule 43 (expr -> expr / expr .)
    ,               reduce using rule 43 (expr -> expr / expr .)
    ELSE            reduce using rule 43 (expr -> expr / expr .)
    )               reduce using rule 43 (expr -> expr / expr .)
    ]               reduce using rule 43 (expr -> expr / expr .)
    :               reduce using rule 43 (expr -> expr / expr .)
    '               shift and go to state 46


state 86

    (44) expr -> expr * expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 44 (expr -> expr * expr .)
    [               reduce using rule 44 (expr -> expr * expr .)
    NEQ             reduce using rule 44 (expr -> expr * expr .)
    EQU             reduce using rule 44 (expr -> expr * expr .)
    GEQ             reduce using rule 44 (expr -> expr * expr .)
    LEQ             reduce using rule 44 (expr -> expr * expr .)
    >               reduce using rule 44 (expr -> expr * expr .)
    <               reduce using rule 44 (expr -> expr * expr .)
    DOTDIV          reduce using rule 44 (expr -> expr * expr .)
    DOTMUL          reduce using rule 44 (expr -> expr * expr .)
    DOTSUB          reduce using rule 44 (expr -> expr * expr .)
    DOTADD          reduce using rule 44 (expr -> expr * expr .)
    /               reduce using rule 44 (expr -> expr * expr .)
    *               reduce using rule 44 (expr -> expr * expr .)
    -               reduce using rule 44 (expr -> expr * expr .)
    +               reduce using rule 44 (expr -> expr * expr .)
    ;               reduce using rule 44 (expr -> expr * expr .)
    {               reduce using rule 44 (expr -> expr * expr .)
    RETURN          reduce using rule 44 (expr -> expr * expr .)
    PRINT           reduce using rule 44 (expr -> expr * expr .)
    CONTINUE        reduce using rule 44 (expr -> expr * expr .)
    BREAK           reduce using rule 44 (expr -> expr * expr .)
    ID              reduce using rule 44 (expr -> expr * expr .)
    FOR             reduce using rule 44 (expr -> expr * expr .)
    WHILE           reduce using rule 44 (expr -> expr * expr .)
    IF              reduce using rule 44 (expr -> expr * expr .)
    (               reduce using rule 44 (expr -> expr * expr .)
    STRING          reduce using rule 44 (expr -> expr * expr .)
    FLOATNUM        reduce using rule 44 (expr -> expr * expr .)
    INTNUM          reduce using rule 44 (expr -> expr * expr .)
    EYE             reduce using rule 44 (expr -> expr * expr .)
    ONES            reduce using rule 44 (expr -> expr * expr .)
    ZEROS           reduce using rule 44 (expr -> expr * expr .)
    $end            reduce using rule 44 (expr -> expr * expr .)
    }               reduce using rule 44 (expr -> expr * expr .)
    ,               reduce using rule 44 (expr -> expr * expr .)
    ELSE            reduce using rule 44 (expr -> expr * expr .)
    )               reduce using rule 44 (expr -> expr * expr .)
    ]               reduce using rule 44 (expr -> expr * expr .)
    :               reduce using rule 44 (expr -> expr * expr .)
    '               shift and go to state 46


state 87

    (45) expr -> expr - expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 45 (expr -> expr - expr .)
    [               reduce using rule 45 (expr -> expr - expr .)
    NEQ             reduce using rule 45 (expr -> expr - expr .)
    EQU             reduce using rule 45 (expr -> expr - expr .)
    GEQ             reduce using rule 45 (expr -> expr - expr .)
    LEQ             reduce using rule 45 (expr -> expr - expr .)
    >               reduce using rule 45 (expr -> expr - expr .)
    <               reduce using rule 45 (expr -> expr - expr .)
    DOTSUB          reduce using rule 45 (expr -> expr - expr .)
    DOTADD          reduce using rule 45 (expr -> expr - expr .)
    -               reduce using rule 45 (expr -> expr - expr .)
    +               reduce using rule 45 (expr -> expr - expr .)
    ;               reduce using rule 45 (expr -> expr - expr .)
    {               reduce using rule 45 (expr -> expr - expr .)
    RETURN          reduce using rule 45 (expr -> expr - expr .)
    PRINT           reduce using rule 45 (expr -> expr - expr .)
    CONTINUE        reduce using rule 45 (expr -> expr - expr .)
    BREAK           reduce using rule 45 (expr -> expr - expr .)
    ID              reduce using rule 45 (expr -> expr - expr .)
    FOR             reduce using rule 45 (expr -> expr - expr .)
    WHILE           reduce using rule 45 (expr -> expr - expr .)
    IF              reduce using rule 45 (expr -> expr - expr .)
    (               reduce using rule 45 (expr -> expr - expr .)
    STRING          reduce using rule 45 (expr -> expr - expr .)
    FLOATNUM        reduce using rule 45 (expr -> expr - expr .)
    INTNUM          reduce using rule 45 (expr -> expr - expr .)
    EYE             reduce using rule 45 (expr -> expr - expr .)
    ONES            reduce using rule 45 (expr -> expr - expr .)
    ZEROS           reduce using rule 45 (expr -> expr - expr .)
    $end            reduce using rule 45 (expr -> expr - expr .)
    }               reduce using rule 45 (expr -> expr - expr .)
    ,               reduce using rule 45 (expr -> expr - expr .)
    ELSE            reduce using rule 45 (expr -> expr - expr .)
    )               reduce using rule 45 (expr -> expr - expr .)
    ]               reduce using rule 45 (expr -> expr - expr .)
    :               reduce using rule 45 (expr -> expr - expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    /               shift and go to state 51
    *               shift and go to state 52


state 88

    (46) expr -> expr + expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    =               reduce using rule 46 (expr -> expr + expr .)
    [               reduce using rule 46 (expr -> expr + expr .)
    NEQ             reduce using rule 46 (expr -> expr + expr .)
    EQU             reduce using rule 46 (expr -> expr + expr .)
    GEQ             reduce using rule 46 (expr -> expr + expr .)
    LEQ             reduce using rule 46 (expr -> expr + expr .)
    >               reduce using rule 46 (expr -> expr + expr .)
    <               reduce using rule 46 (expr -> expr + expr .)
    DOTSUB          reduce using rule 46 (expr -> expr + expr .)
    DOTADD          reduce using rule 46 (expr -> expr + expr .)
    -               reduce using rule 46 (expr -> expr + expr .)
    +               reduce using rule 46 (expr -> expr + expr .)
    ;               reduce using rule 46 (expr -> expr + expr .)
    {               reduce using rule 46 (expr -> expr + expr .)
    RETURN          reduce using rule 46 (expr -> expr + expr .)
    PRINT           reduce using rule 46 (expr -> expr + expr .)
    CONTINUE        reduce using rule 46 (expr -> expr + expr .)
    BREAK           reduce using rule 46 (expr -> expr + expr .)
    ID              reduce using rule 46 (expr -> expr + expr .)
    FOR             reduce using rule 46 (expr -> expr + expr .)
    WHILE           reduce using rule 46 (expr -> expr + expr .)
    IF              reduce using rule 46 (expr -> expr + expr .)
    (               reduce using rule 46 (expr -> expr + expr .)
    STRING          reduce using rule 46 (expr -> expr + expr .)
    FLOATNUM        reduce using rule 46 (expr -> expr + expr .)
    INTNUM          reduce using rule 46 (expr -> expr + expr .)
    EYE             reduce using rule 46 (expr -> expr + expr .)
    ONES            reduce using rule 46 (expr -> expr + expr .)
    ZEROS           reduce using rule 46 (expr -> expr + expr .)
    $end            reduce using rule 46 (expr -> expr + expr .)
    }               reduce using rule 46 (expr -> expr + expr .)
    ,               reduce using rule 46 (expr -> expr + expr .)
    ELSE            reduce using rule 46 (expr -> expr + expr .)
    )               reduce using rule 46 (expr -> expr + expr .)
    ]               reduce using rule 46 (expr -> expr + expr .)
    :               reduce using rule 46 (expr -> expr + expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    /               shift and go to state 51
    *               shift and go to state 52


state 89

    (19) stmt -> FOR ID = . expr : expr block
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 101
    term                           shift and go to state 17

state 90

    (20) stmt -> WHILE ( expr . ) block
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 102
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 91

    (36) expr -> ( expr ) .
    =               reduce using rule 36 (expr -> ( expr ) .)
    [               reduce using rule 36 (expr -> ( expr ) .)
    NEQ             reduce using rule 36 (expr -> ( expr ) .)
    EQU             reduce using rule 36 (expr -> ( expr ) .)
    GEQ             reduce using rule 36 (expr -> ( expr ) .)
    LEQ             reduce using rule 36 (expr -> ( expr ) .)
    >               reduce using rule 36 (expr -> ( expr ) .)
    <               reduce using rule 36 (expr -> ( expr ) .)
    '               reduce using rule 36 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 36 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 36 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 36 (expr -> ( expr ) .)
    DOTADD          reduce using rule 36 (expr -> ( expr ) .)
    /               reduce using rule 36 (expr -> ( expr ) .)
    *               reduce using rule 36 (expr -> ( expr ) .)
    -               reduce using rule 36 (expr -> ( expr ) .)
    +               reduce using rule 36 (expr -> ( expr ) .)
    ;               reduce using rule 36 (expr -> ( expr ) .)
    {               reduce using rule 36 (expr -> ( expr ) .)
    RETURN          reduce using rule 36 (expr -> ( expr ) .)
    PRINT           reduce using rule 36 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 36 (expr -> ( expr ) .)
    BREAK           reduce using rule 36 (expr -> ( expr ) .)
    ID              reduce using rule 36 (expr -> ( expr ) .)
    FOR             reduce using rule 36 (expr -> ( expr ) .)
    WHILE           reduce using rule 36 (expr -> ( expr ) .)
    IF              reduce using rule 36 (expr -> ( expr ) .)
    (               reduce using rule 36 (expr -> ( expr ) .)
    STRING          reduce using rule 36 (expr -> ( expr ) .)
    FLOATNUM        reduce using rule 36 (expr -> ( expr ) .)
    INTNUM          reduce using rule 36 (expr -> ( expr ) .)
    EYE             reduce using rule 36 (expr -> ( expr ) .)
    ONES            reduce using rule 36 (expr -> ( expr ) .)
    ZEROS           reduce using rule 36 (expr -> ( expr ) .)
    $end            reduce using rule 36 (expr -> ( expr ) .)
    }               reduce using rule 36 (expr -> ( expr ) .)
    ,               reduce using rule 36 (expr -> ( expr ) .)
    ELSE            reduce using rule 36 (expr -> ( expr ) .)
    )               reduce using rule 36 (expr -> ( expr ) .)
    ]               reduce using rule 36 (expr -> ( expr ) .)
    :               reduce using rule 36 (expr -> ( expr ) .)


state 92

    (21) stmt -> IF ( expr . ) block
    (22) stmt -> IF ( expr . ) block ELSE block
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 103
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 93

    (47) outerlist -> [ innerlist . ]
    (50) innerlist -> innerlist . , expr
    ]               shift and go to state 104
    ,               shift and go to state 68


state 94

    (28) expr -> [ outerlist ] .
    =               reduce using rule 28 (expr -> [ outerlist ] .)
    [               reduce using rule 28 (expr -> [ outerlist ] .)
    NEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    EQU             reduce using rule 28 (expr -> [ outerlist ] .)
    GEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    LEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    >               reduce using rule 28 (expr -> [ outerlist ] .)
    <               reduce using rule 28 (expr -> [ outerlist ] .)
    '               reduce using rule 28 (expr -> [ outerlist ] .)
    DOTDIV          reduce using rule 28 (expr -> [ outerlist ] .)
    DOTMUL          reduce using rule 28 (expr -> [ outerlist ] .)
    DOTSUB          reduce using rule 28 (expr -> [ outerlist ] .)
    DOTADD          reduce using rule 28 (expr -> [ outerlist ] .)
    /               reduce using rule 28 (expr -> [ outerlist ] .)
    *               reduce using rule 28 (expr -> [ outerlist ] .)
    -               reduce using rule 28 (expr -> [ outerlist ] .)
    +               reduce using rule 28 (expr -> [ outerlist ] .)
    ;               reduce using rule 28 (expr -> [ outerlist ] .)
    {               reduce using rule 28 (expr -> [ outerlist ] .)
    RETURN          reduce using rule 28 (expr -> [ outerlist ] .)
    PRINT           reduce using rule 28 (expr -> [ outerlist ] .)
    CONTINUE        reduce using rule 28 (expr -> [ outerlist ] .)
    BREAK           reduce using rule 28 (expr -> [ outerlist ] .)
    ID              reduce using rule 28 (expr -> [ outerlist ] .)
    FOR             reduce using rule 28 (expr -> [ outerlist ] .)
    WHILE           reduce using rule 28 (expr -> [ outerlist ] .)
    IF              reduce using rule 28 (expr -> [ outerlist ] .)
    (               reduce using rule 28 (expr -> [ outerlist ] .)
    STRING          reduce using rule 28 (expr -> [ outerlist ] .)
    FLOATNUM        reduce using rule 28 (expr -> [ outerlist ] .)
    INTNUM          reduce using rule 28 (expr -> [ outerlist ] .)
    EYE             reduce using rule 28 (expr -> [ outerlist ] .)
    ONES            reduce using rule 28 (expr -> [ outerlist ] .)
    ZEROS           reduce using rule 28 (expr -> [ outerlist ] .)
    $end            reduce using rule 28 (expr -> [ outerlist ] .)
    }               reduce using rule 28 (expr -> [ outerlist ] .)
    ,               reduce using rule 28 (expr -> [ outerlist ] .)
    ELSE            reduce using rule 28 (expr -> [ outerlist ] .)
    )               reduce using rule 28 (expr -> [ outerlist ] .)
    ]               reduce using rule 28 (expr -> [ outerlist ] .)
    :               reduce using rule 28 (expr -> [ outerlist ] .)


state 95

    (48) outerlist -> outerlist , . [ innerlist ]
    [               shift and go to state 105


state 96

    (55) term -> EYE ( expr . )
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 106
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 97

    (56) term -> ONES ( expr . )
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 107
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 98

    (57) term -> ZEROS ( expr . )
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    )               shift and go to state 108
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 99

    (50) innerlist -> innerlist , expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for - resolved as shift
    ,               reduce using rule 50 (innerlist -> innerlist , expr .)
    ;               reduce using rule 50 (innerlist -> innerlist , expr .)
    {               reduce using rule 50 (innerlist -> innerlist , expr .)
    RETURN          reduce using rule 50 (innerlist -> innerlist , expr .)
    PRINT           reduce using rule 50 (innerlist -> innerlist , expr .)
    CONTINUE        reduce using rule 50 (innerlist -> innerlist , expr .)
    BREAK           reduce using rule 50 (innerlist -> innerlist , expr .)
    ID              reduce using rule 50 (innerlist -> innerlist , expr .)
    FOR             reduce using rule 50 (innerlist -> innerlist , expr .)
    WHILE           reduce using rule 50 (innerlist -> innerlist , expr .)
    IF              reduce using rule 50 (innerlist -> innerlist , expr .)
    (               reduce using rule 50 (innerlist -> innerlist , expr .)
    STRING          reduce using rule 50 (innerlist -> innerlist , expr .)
    FLOATNUM        reduce using rule 50 (innerlist -> innerlist , expr .)
    INTNUM          reduce using rule 50 (innerlist -> innerlist , expr .)
    EYE             reduce using rule 50 (innerlist -> innerlist , expr .)
    ONES            reduce using rule 50 (innerlist -> innerlist , expr .)
    ZEROS           reduce using rule 50 (innerlist -> innerlist , expr .)
    $end            reduce using rule 50 (innerlist -> innerlist , expr .)
    }               reduce using rule 50 (innerlist -> innerlist , expr .)
    ELSE            reduce using rule 50 (innerlist -> innerlist , expr .)
    ]               reduce using rule 50 (innerlist -> innerlist , expr .)
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 100

    (27) expr -> expr [ expr , . expr ]
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 109
    term                           shift and go to state 17

state 101

    (19) stmt -> FOR ID = expr . : expr block
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    :               shift and go to state 110
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 102

    (20) stmt -> WHILE ( expr ) . block
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 11
    block                          shift and go to state 111
    stmt                           shift and go to state 112
    term                           shift and go to state 17

state 103

    (21) stmt -> IF ( expr ) . block
    (22) stmt -> IF ( expr ) . block ELSE block
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 11
    block                          shift and go to state 113
    stmt                           shift and go to state 112
    term                           shift and go to state 17

state 104

    (47) outerlist -> [ innerlist ] .
    ]               reduce using rule 47 (outerlist -> [ innerlist ] .)
    ,               reduce using rule 47 (outerlist -> [ innerlist ] .)


state 105

    (48) outerlist -> outerlist , [ . innerlist ]
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    innerlist                      shift and go to state 114
    expr                           shift and go to state 31
    term                           shift and go to state 17

state 106

    (55) term -> EYE ( expr ) .
    =               reduce using rule 55 (term -> EYE ( expr ) .)
    [               reduce using rule 55 (term -> EYE ( expr ) .)
    NEQ             reduce using rule 55 (term -> EYE ( expr ) .)
    EQU             reduce using rule 55 (term -> EYE ( expr ) .)
    GEQ             reduce using rule 55 (term -> EYE ( expr ) .)
    LEQ             reduce using rule 55 (term -> EYE ( expr ) .)
    >               reduce using rule 55 (term -> EYE ( expr ) .)
    <               reduce using rule 55 (term -> EYE ( expr ) .)
    '               reduce using rule 55 (term -> EYE ( expr ) .)
    DOTDIV          reduce using rule 55 (term -> EYE ( expr ) .)
    DOTMUL          reduce using rule 55 (term -> EYE ( expr ) .)
    DOTSUB          reduce using rule 55 (term -> EYE ( expr ) .)
    DOTADD          reduce using rule 55 (term -> EYE ( expr ) .)
    /               reduce using rule 55 (term -> EYE ( expr ) .)
    *               reduce using rule 55 (term -> EYE ( expr ) .)
    -               reduce using rule 55 (term -> EYE ( expr ) .)
    +               reduce using rule 55 (term -> EYE ( expr ) .)
    ;               reduce using rule 55 (term -> EYE ( expr ) .)
    {               reduce using rule 55 (term -> EYE ( expr ) .)
    RETURN          reduce using rule 55 (term -> EYE ( expr ) .)
    PRINT           reduce using rule 55 (term -> EYE ( expr ) .)
    CONTINUE        reduce using rule 55 (term -> EYE ( expr ) .)
    BREAK           reduce using rule 55 (term -> EYE ( expr ) .)
    ID              reduce using rule 55 (term -> EYE ( expr ) .)
    FOR             reduce using rule 55 (term -> EYE ( expr ) .)
    WHILE           reduce using rule 55 (term -> EYE ( expr ) .)
    IF              reduce using rule 55 (term -> EYE ( expr ) .)
    (               reduce using rule 55 (term -> EYE ( expr ) .)
    STRING          reduce using rule 55 (term -> EYE ( expr ) .)
    FLOATNUM        reduce using rule 55 (term -> EYE ( expr ) .)
    INTNUM          reduce using rule 55 (term -> EYE ( expr ) .)
    EYE             reduce using rule 55 (term -> EYE ( expr ) .)
    ONES            reduce using rule 55 (term -> EYE ( expr ) .)
    ZEROS           reduce using rule 55 (term -> EYE ( expr ) .)
    $end            reduce using rule 55 (term -> EYE ( expr ) .)
    }               reduce using rule 55 (term -> EYE ( expr ) .)
    ,               reduce using rule 55 (term -> EYE ( expr ) .)
    ELSE            reduce using rule 55 (term -> EYE ( expr ) .)
    )               reduce using rule 55 (term -> EYE ( expr ) .)
    ]               reduce using rule 55 (term -> EYE ( expr ) .)
    :               reduce using rule 55 (term -> EYE ( expr ) .)


state 107

    (56) term -> ONES ( expr ) .
    =               reduce using rule 56 (term -> ONES ( expr ) .)
    [               reduce using rule 56 (term -> ONES ( expr ) .)
    NEQ             reduce using rule 56 (term -> ONES ( expr ) .)
    EQU             reduce using rule 56 (term -> ONES ( expr ) .)
    GEQ             reduce using rule 56 (term -> ONES ( expr ) .)
    LEQ             reduce using rule 56 (term -> ONES ( expr ) .)
    >               reduce using rule 56 (term -> ONES ( expr ) .)
    <               reduce using rule 56 (term -> ONES ( expr ) .)
    '               reduce using rule 56 (term -> ONES ( expr ) .)
    DOTDIV          reduce using rule 56 (term -> ONES ( expr ) .)
    DOTMUL          reduce using rule 56 (term -> ONES ( expr ) .)
    DOTSUB          reduce using rule 56 (term -> ONES ( expr ) .)
    DOTADD          reduce using rule 56 (term -> ONES ( expr ) .)
    /               reduce using rule 56 (term -> ONES ( expr ) .)
    *               reduce using rule 56 (term -> ONES ( expr ) .)
    -               reduce using rule 56 (term -> ONES ( expr ) .)
    +               reduce using rule 56 (term -> ONES ( expr ) .)
    ;               reduce using rule 56 (term -> ONES ( expr ) .)
    {               reduce using rule 56 (term -> ONES ( expr ) .)
    RETURN          reduce using rule 56 (term -> ONES ( expr ) .)
    PRINT           reduce using rule 56 (term -> ONES ( expr ) .)
    CONTINUE        reduce using rule 56 (term -> ONES ( expr ) .)
    BREAK           reduce using rule 56 (term -> ONES ( expr ) .)
    ID              reduce using rule 56 (term -> ONES ( expr ) .)
    FOR             reduce using rule 56 (term -> ONES ( expr ) .)
    WHILE           reduce using rule 56 (term -> ONES ( expr ) .)
    IF              reduce using rule 56 (term -> ONES ( expr ) .)
    (               reduce using rule 56 (term -> ONES ( expr ) .)
    STRING          reduce using rule 56 (term -> ONES ( expr ) .)
    FLOATNUM        reduce using rule 56 (term -> ONES ( expr ) .)
    INTNUM          reduce using rule 56 (term -> ONES ( expr ) .)
    EYE             reduce using rule 56 (term -> ONES ( expr ) .)
    ONES            reduce using rule 56 (term -> ONES ( expr ) .)
    ZEROS           reduce using rule 56 (term -> ONES ( expr ) .)
    $end            reduce using rule 56 (term -> ONES ( expr ) .)
    }               reduce using rule 56 (term -> ONES ( expr ) .)
    ,               reduce using rule 56 (term -> ONES ( expr ) .)
    ELSE            reduce using rule 56 (term -> ONES ( expr ) .)
    )               reduce using rule 56 (term -> ONES ( expr ) .)
    ]               reduce using rule 56 (term -> ONES ( expr ) .)
    :               reduce using rule 56 (term -> ONES ( expr ) .)


state 108

    (57) term -> ZEROS ( expr ) .
    =               reduce using rule 57 (term -> ZEROS ( expr ) .)
    [               reduce using rule 57 (term -> ZEROS ( expr ) .)
    NEQ             reduce using rule 57 (term -> ZEROS ( expr ) .)
    EQU             reduce using rule 57 (term -> ZEROS ( expr ) .)
    GEQ             reduce using rule 57 (term -> ZEROS ( expr ) .)
    LEQ             reduce using rule 57 (term -> ZEROS ( expr ) .)
    >               reduce using rule 57 (term -> ZEROS ( expr ) .)
    <               reduce using rule 57 (term -> ZEROS ( expr ) .)
    '               reduce using rule 57 (term -> ZEROS ( expr ) .)
    DOTDIV          reduce using rule 57 (term -> ZEROS ( expr ) .)
    DOTMUL          reduce using rule 57 (term -> ZEROS ( expr ) .)
    DOTSUB          reduce using rule 57 (term -> ZEROS ( expr ) .)
    DOTADD          reduce using rule 57 (term -> ZEROS ( expr ) .)
    /               reduce using rule 57 (term -> ZEROS ( expr ) .)
    *               reduce using rule 57 (term -> ZEROS ( expr ) .)
    -               reduce using rule 57 (term -> ZEROS ( expr ) .)
    +               reduce using rule 57 (term -> ZEROS ( expr ) .)
    ;               reduce using rule 57 (term -> ZEROS ( expr ) .)
    {               reduce using rule 57 (term -> ZEROS ( expr ) .)
    RETURN          reduce using rule 57 (term -> ZEROS ( expr ) .)
    PRINT           reduce using rule 57 (term -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 57 (term -> ZEROS ( expr ) .)
    BREAK           reduce using rule 57 (term -> ZEROS ( expr ) .)
    ID              reduce using rule 57 (term -> ZEROS ( expr ) .)
    FOR             reduce using rule 57 (term -> ZEROS ( expr ) .)
    WHILE           reduce using rule 57 (term -> ZEROS ( expr ) .)
    IF              reduce using rule 57 (term -> ZEROS ( expr ) .)
    (               reduce using rule 57 (term -> ZEROS ( expr ) .)
    STRING          reduce using rule 57 (term -> ZEROS ( expr ) .)
    FLOATNUM        reduce using rule 57 (term -> ZEROS ( expr ) .)
    INTNUM          reduce using rule 57 (term -> ZEROS ( expr ) .)
    EYE             reduce using rule 57 (term -> ZEROS ( expr ) .)
    ONES            reduce using rule 57 (term -> ZEROS ( expr ) .)
    ZEROS           reduce using rule 57 (term -> ZEROS ( expr ) .)
    $end            reduce using rule 57 (term -> ZEROS ( expr ) .)
    }               reduce using rule 57 (term -> ZEROS ( expr ) .)
    ,               reduce using rule 57 (term -> ZEROS ( expr ) .)
    ELSE            reduce using rule 57 (term -> ZEROS ( expr ) .)
    )               reduce using rule 57 (term -> ZEROS ( expr ) .)
    ]               reduce using rule 57 (term -> ZEROS ( expr ) .)
    :               reduce using rule 57 (term -> ZEROS ( expr ) .)


state 109

    (27) expr -> expr [ expr , expr . ]
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    ]               shift and go to state 115
    [               shift and go to state 39
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 110

    (19) stmt -> FOR ID = expr : . expr block
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 116
    term                           shift and go to state 17

state 111

    (20) stmt -> WHILE ( expr ) block .
    ;               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    {               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    RETURN          reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    PRINT           reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    CONTINUE        reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    BREAK           reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    ID              reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    FOR             reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    WHILE           reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    IF              reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    [               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    (               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    -               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    STRING          reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    FLOATNUM        reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    INTNUM          reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    EYE             reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    ONES            reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    ZEROS           reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    $end            reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    }               reduce using rule 20 (stmt -> WHILE ( expr ) block .)
    ELSE            reduce using rule 20 (stmt -> WHILE ( expr ) block .)


state 112

    (24) block -> stmt . ;
    (25) block -> stmt .
  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 117
    {               reduce using rule 25 (block -> stmt .)
    RETURN          reduce using rule 25 (block -> stmt .)
    PRINT           reduce using rule 25 (block -> stmt .)
    CONTINUE        reduce using rule 25 (block -> stmt .)
    BREAK           reduce using rule 25 (block -> stmt .)
    ID              reduce using rule 25 (block -> stmt .)
    FOR             reduce using rule 25 (block -> stmt .)
    WHILE           reduce using rule 25 (block -> stmt .)
    IF              reduce using rule 25 (block -> stmt .)
    [               reduce using rule 25 (block -> stmt .)
    (               reduce using rule 25 (block -> stmt .)
    -               reduce using rule 25 (block -> stmt .)
    STRING          reduce using rule 25 (block -> stmt .)
    FLOATNUM        reduce using rule 25 (block -> stmt .)
    INTNUM          reduce using rule 25 (block -> stmt .)
    EYE             reduce using rule 25 (block -> stmt .)
    ONES            reduce using rule 25 (block -> stmt .)
    ZEROS           reduce using rule 25 (block -> stmt .)
    $end            reduce using rule 25 (block -> stmt .)
    }               reduce using rule 25 (block -> stmt .)
    ELSE            reduce using rule 25 (block -> stmt .)


state 113

    (21) stmt -> IF ( expr ) block .
    (22) stmt -> IF ( expr ) block . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    ;               reduce using rule 21 (stmt -> IF ( expr ) block .)
    {               reduce using rule 21 (stmt -> IF ( expr ) block .)
    RETURN          reduce using rule 21 (stmt -> IF ( expr ) block .)
    PRINT           reduce using rule 21 (stmt -> IF ( expr ) block .)
    CONTINUE        reduce using rule 21 (stmt -> IF ( expr ) block .)
    BREAK           reduce using rule 21 (stmt -> IF ( expr ) block .)
    ID              reduce using rule 21 (stmt -> IF ( expr ) block .)
    FOR             reduce using rule 21 (stmt -> IF ( expr ) block .)
    WHILE           reduce using rule 21 (stmt -> IF ( expr ) block .)
    IF              reduce using rule 21 (stmt -> IF ( expr ) block .)
    [               reduce using rule 21 (stmt -> IF ( expr ) block .)
    (               reduce using rule 21 (stmt -> IF ( expr ) block .)
    -               reduce using rule 21 (stmt -> IF ( expr ) block .)
    STRING          reduce using rule 21 (stmt -> IF ( expr ) block .)
    FLOATNUM        reduce using rule 21 (stmt -> IF ( expr ) block .)
    INTNUM          reduce using rule 21 (stmt -> IF ( expr ) block .)
    EYE             reduce using rule 21 (stmt -> IF ( expr ) block .)
    ONES            reduce using rule 21 (stmt -> IF ( expr ) block .)
    ZEROS           reduce using rule 21 (stmt -> IF ( expr ) block .)
    $end            reduce using rule 21 (stmt -> IF ( expr ) block .)
    }               reduce using rule 21 (stmt -> IF ( expr ) block .)
    ELSE            shift and go to state 118


state 114

    (48) outerlist -> outerlist , [ innerlist . ]
    (50) innerlist -> innerlist . , expr
    ]               shift and go to state 119
    ,               shift and go to state 68


state 115

    (27) expr -> expr [ expr , expr ] .
    =               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    [               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    NEQ             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    EQU             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    GEQ             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    LEQ             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    >               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    <               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    '               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    DOTDIV          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    DOTMUL          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    DOTSUB          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    DOTADD          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    /               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    *               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    -               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    +               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ;               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    {               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    RETURN          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    PRINT           reduce using rule 27 (expr -> expr [ expr , expr ] .)
    CONTINUE        reduce using rule 27 (expr -> expr [ expr , expr ] .)
    BREAK           reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ID              reduce using rule 27 (expr -> expr [ expr , expr ] .)
    FOR             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    WHILE           reduce using rule 27 (expr -> expr [ expr , expr ] .)
    IF              reduce using rule 27 (expr -> expr [ expr , expr ] .)
    (               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    STRING          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    FLOATNUM        reduce using rule 27 (expr -> expr [ expr , expr ] .)
    INTNUM          reduce using rule 27 (expr -> expr [ expr , expr ] .)
    EYE             reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ONES            reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ZEROS           reduce using rule 27 (expr -> expr [ expr , expr ] .)
    $end            reduce using rule 27 (expr -> expr [ expr , expr ] .)
    }               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ,               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ELSE            reduce using rule 27 (expr -> expr [ expr , expr ] .)
    )               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    ]               reduce using rule 27 (expr -> expr [ expr , expr ] .)
    :               reduce using rule 27 (expr -> expr [ expr , expr ] .)


state 116

    (19) stmt -> FOR ID = expr : expr . block
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 121
    NEQ             shift and go to state 40
    EQU             shift and go to state 41
    GEQ             shift and go to state 42
    LEQ             shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    DOTSUB          shift and go to state 49
    DOTADD          shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 122
    +               shift and go to state 54
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    (               shift and go to state 14
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 11
    block                          shift and go to state 120
    stmt                           shift and go to state 112
    term                           shift and go to state 17

state 117

    (24) block -> stmt ; .
    ;               reduce using rule 24 (block -> stmt ; .)
    {               reduce using rule 24 (block -> stmt ; .)
    RETURN          reduce using rule 24 (block -> stmt ; .)
    PRINT           reduce using rule 24 (block -> stmt ; .)
    CONTINUE        reduce using rule 24 (block -> stmt ; .)
    BREAK           reduce using rule 24 (block -> stmt ; .)
    ID              reduce using rule 24 (block -> stmt ; .)
    FOR             reduce using rule 24 (block -> stmt ; .)
    WHILE           reduce using rule 24 (block -> stmt ; .)
    IF              reduce using rule 24 (block -> stmt ; .)
    [               reduce using rule 24 (block -> stmt ; .)
    (               reduce using rule 24 (block -> stmt ; .)
    -               reduce using rule 24 (block -> stmt ; .)
    STRING          reduce using rule 24 (block -> stmt ; .)
    FLOATNUM        reduce using rule 24 (block -> stmt ; .)
    INTNUM          reduce using rule 24 (block -> stmt ; .)
    EYE             reduce using rule 24 (block -> stmt ; .)
    ONES            reduce using rule 24 (block -> stmt ; .)
    ZEROS           reduce using rule 24 (block -> stmt ; .)
    $end            reduce using rule 24 (block -> stmt ; .)
    }               reduce using rule 24 (block -> stmt ; .)
    ELSE            reduce using rule 24 (block -> stmt ; .)


state 118

    (22) stmt -> IF ( expr ) block ELSE . block
    (24) block -> . stmt ;
    (25) block -> . stmt
    (26) block -> . { stmt_set }
    (10) stmt -> . RETURN innerlist
    (11) stmt -> . PRINT innerlist
    (12) stmt -> . CONTINUE
    (13) stmt -> . BREAK
    (14) stmt -> . ID DIVASSIGN expr
    (15) stmt -> . ID MULASSIGN expr
    (16) stmt -> . ID SUBASSIGN expr
    (17) stmt -> . ID ADDASSIGN expr
    (18) stmt -> . expr = expr
    (19) stmt -> . FOR ID = expr : expr block
    (20) stmt -> . WHILE ( expr ) block
    (21) stmt -> . IF ( expr ) block
    (22) stmt -> . IF ( expr ) block ELSE block
    (23) stmt -> . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    {               shift and go to state 5
    RETURN          shift and go to state 6
    PRINT           shift and go to state 7
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    ID              shift and go to state 10
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    IF              shift and go to state 15
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 11
    block                          shift and go to state 123
    stmt                           shift and go to state 112
    term                           shift and go to state 17

state 119

    (48) outerlist -> outerlist , [ innerlist ] .
    ]               reduce using rule 48 (outerlist -> outerlist , [ innerlist ] .)
    ,               reduce using rule 48 (outerlist -> outerlist , [ innerlist ] .)


state 120

    (19) stmt -> FOR ID = expr : expr block .
    ;               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    {               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    RETURN          reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    PRINT           reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    CONTINUE        reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    BREAK           reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    ID              reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    FOR             reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    WHILE           reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    IF              reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    [               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    (               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    -               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    STRING          reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    FLOATNUM        reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    INTNUM          reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    EYE             reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    ONES            reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    ZEROS           reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    $end            reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    }               reduce using rule 19 (stmt -> FOR ID = expr : expr block .)
    ELSE            reduce using rule 19 (stmt -> FOR ID = expr : expr block .)


state 121

    (27) expr -> expr [ . expr , expr ]
    (28) expr -> [ . outerlist ]
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (47) outerlist -> . [ innerlist ]
    (48) outerlist -> . outerlist , [ innerlist ]
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 124
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 74
    outerlist                      shift and go to state 60
    term                           shift and go to state 17

state 122

    (45) expr -> expr - . expr
    (38) expr -> - . expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 16
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    expr                           shift and go to state 125
    term                           shift and go to state 17

state 123

    (22) stmt -> IF ( expr ) block ELSE block .
    ;               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    {               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    RETURN          reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    PRINT           reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    CONTINUE        reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    BREAK           reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    ID              reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    FOR             reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    WHILE           reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    IF              reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    [               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    (               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    -               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    STRING          reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    FLOATNUM        reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    INTNUM          reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    EYE             reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    ONES            reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    ZEROS           reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    $end            reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    }               reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)
    ELSE            reduce using rule 22 (stmt -> IF ( expr ) block ELSE block .)


state 124

    (28) expr -> [ . outerlist ]
    (47) outerlist -> [ . innerlist ]
    (47) outerlist -> . [ innerlist ]
    (48) outerlist -> . outerlist , [ innerlist ]
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 126
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    outerlist                      shift and go to state 60
    innerlist                      shift and go to state 93
    expr                           shift and go to state 31
    term                           shift and go to state 17

state 125

    (45) expr -> expr - expr .
    (38) expr -> - expr .
    (27) expr -> expr . [ expr , expr ]
    (30) expr -> expr . NEQ expr
    (31) expr -> expr . EQU expr
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (37) expr -> expr . '
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . DOTSUB expr
    (42) expr -> expr . DOTADD expr
    (43) expr -> expr . / expr
    (44) expr -> expr . * expr
    (45) expr -> expr . - expr
    (46) expr -> expr . + expr
  ! reduce/reduce conflict for [ resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for NEQ resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for EQU resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for GEQ resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for LEQ resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for > resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for < resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for ' resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTDIV resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTMUL resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTSUB resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTADD resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for / resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for * resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for - resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for + resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for { resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for RETURN resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for PRINT resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for BREAK resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for ID resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for FOR resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for WHILE resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for IF resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for ( resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for STRING resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for INTNUM resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for EYE resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for ONES resolved using rule 45 (expr -> expr - expr .)
  ! reduce/reduce conflict for ZEROS resolved using rule 45 (expr -> expr - expr .)
    [               reduce using rule 45 (expr -> expr - expr .)
    NEQ             reduce using rule 45 (expr -> expr - expr .)
    EQU             reduce using rule 45 (expr -> expr - expr .)
    GEQ             reduce using rule 45 (expr -> expr - expr .)
    LEQ             reduce using rule 45 (expr -> expr - expr .)
    >               reduce using rule 45 (expr -> expr - expr .)
    <               reduce using rule 45 (expr -> expr - expr .)
    DOTSUB          reduce using rule 45 (expr -> expr - expr .)
    DOTADD          reduce using rule 45 (expr -> expr - expr .)
    -               reduce using rule 45 (expr -> expr - expr .)
    +               reduce using rule 45 (expr -> expr - expr .)
    {               reduce using rule 45 (expr -> expr - expr .)
    RETURN          reduce using rule 45 (expr -> expr - expr .)
    PRINT           reduce using rule 45 (expr -> expr - expr .)
    CONTINUE        reduce using rule 45 (expr -> expr - expr .)
    BREAK           reduce using rule 45 (expr -> expr - expr .)
    ID              reduce using rule 45 (expr -> expr - expr .)
    FOR             reduce using rule 45 (expr -> expr - expr .)
    WHILE           reduce using rule 45 (expr -> expr - expr .)
    IF              reduce using rule 45 (expr -> expr - expr .)
    (               reduce using rule 45 (expr -> expr - expr .)
    STRING          reduce using rule 45 (expr -> expr - expr .)
    FLOATNUM        reduce using rule 45 (expr -> expr - expr .)
    INTNUM          reduce using rule 45 (expr -> expr - expr .)
    EYE             reduce using rule 45 (expr -> expr - expr .)
    ONES            reduce using rule 45 (expr -> expr - expr .)
    ZEROS           reduce using rule 45 (expr -> expr - expr .)
    =               reduce using rule 38 (expr -> - expr .)
    ;               reduce using rule 38 (expr -> - expr .)
    $end            reduce using rule 38 (expr -> - expr .)
    }               reduce using rule 38 (expr -> - expr .)
    ELSE            reduce using rule 38 (expr -> - expr .)
    '               shift and go to state 46
    DOTDIV          shift and go to state 47
    DOTMUL          shift and go to state 48
    /               shift and go to state 51
    *               shift and go to state 52


state 126

    (47) outerlist -> [ . innerlist ]
    (28) expr -> [ . outerlist ]
    (49) innerlist -> . expr
    (50) innerlist -> . innerlist , expr
    (47) outerlist -> . [ innerlist ]
    (48) outerlist -> . outerlist , [ innerlist ]
    (27) expr -> . expr [ expr , expr ]
    (28) expr -> . [ outerlist ]
    (29) expr -> . term
    (30) expr -> . expr NEQ expr
    (31) expr -> . expr EQU expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . ( expr )
    (37) expr -> . expr '
    (38) expr -> . - expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr DOTSUB expr
    (42) expr -> . expr DOTADD expr
    (43) expr -> . expr / expr
    (44) expr -> . expr * expr
    (45) expr -> . expr - expr
    (46) expr -> . expr + expr
    (51) term -> . ID
    (52) term -> . STRING
    (53) term -> . FLOATNUM
    (54) term -> . INTNUM
    (55) term -> . EYE ( expr )
    (56) term -> . ONES ( expr )
    (57) term -> . ZEROS ( expr )
    [               shift and go to state 126
    (               shift and go to state 14
    -               shift and go to state 18
    ID              shift and go to state 32
    STRING          shift and go to state 19
    FLOATNUM        shift and go to state 20
    INTNUM          shift and go to state 21
    EYE             shift and go to state 22
    ONES            shift and go to state 23
    ZEROS           shift and go to state 24

    innerlist                      shift and go to state 93
    outerlist                      shift and go to state 60
    expr                           shift and go to state 31
    term                           shift and go to state 17

Conflicts:

shift/reduce conflict for ; in state 4 resolved as shift
shift/reduce conflict for [ in state 11 resolved as shift
shift/reduce conflict for - in state 11 resolved as shift
shift/reduce conflict for ; in state 26 resolved as shift
shift/reduce conflict for [ in state 31 resolved as shift
shift/reduce conflict for - in state 31 resolved as shift
shift/reduce conflict for [ in state 99 resolved as shift
shift/reduce conflict for - in state 99 resolved as shift
shift/reduce conflict for ; in state 112 resolved as shift
shift/reduce conflict for ELSE in state 113 resolved as shift
reduce/reduce conflict in state 4 resolved using rule stmt_set -> stmt
rejected rule (block -> stmt) in state 4
reduce/reduce conflict in state 26 resolved using rule stmt_set -> stmt_set stmt
rejected rule (block -> stmt) in state 26
reduce/reduce conflict in state 28 resolved using rule stmt_set -> stmt ;
rejected rule (block -> stmt ;) in state 28
reduce/reduce conflict in state 66 resolved using rule stmt_set -> stmt_set stmt ;
rejected rule (block -> stmt ;) in state 66
reduce/reduce conflict in state 125 resolved using rule expr -> expr - expr  [precedence=left, level=5]
rejected rule (expr -> - expr  [precedence=right, level=7]) in state 125
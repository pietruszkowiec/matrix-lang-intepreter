Grammar:

Rule 0     S' -> program
Rule 1     program -> stmt_set
Rule 2     stmt_set -> stmt_set stmt
Rule 3     stmt_set -> stmt
Rule 4     stmt -> RETURN vector ;
Rule 5     stmt -> PRINT vector ;
Rule 6     stmt -> CONTINUE ;
Rule 7     stmt -> BREAK ;
Rule 8     stmt -> term DIVASSIGN expr ;
Rule 9     stmt -> term MULASSIGN expr ;
Rule 10    stmt -> term SUBASSIGN expr ;
Rule 11    stmt -> term ADDASSIGN expr ;
Rule 12    stmt -> term = expr ;
Rule 13    stmt -> FOR term = expr : expr stmt
Rule 14    stmt -> WHILE ( expr ) stmt
Rule 15    stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 16    stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 17    stmt -> { stmt_set }
Rule 18    expr -> [ vector ]
Rule 19    expr -> term
Rule 20    expr -> expr NEQ expr  [precedence=nonassoc, level=4]
Rule 21    expr -> expr EQU expr  [precedence=nonassoc, level=4]
Rule 22    expr -> expr GEQ expr  [precedence=nonassoc, level=5]
Rule 23    expr -> expr LEQ expr  [precedence=nonassoc, level=5]
Rule 24    expr -> expr > expr  [precedence=nonassoc, level=5]
Rule 25    expr -> expr < expr  [precedence=nonassoc, level=5]
Rule 26    expr -> ( expr )
Rule 27    expr -> expr '  [precedence=left, level=9]
Rule 28    expr -> - expr  [precedence=right, level=8]
Rule 29    expr -> + expr  [precedence=right, level=8]
Rule 30    expr -> expr DOTDIV expr  [precedence=left, level=7]
Rule 31    expr -> expr DOTMUL expr  [precedence=left, level=7]
Rule 32    expr -> expr DOTSUB expr  [precedence=left, level=6]
Rule 33    expr -> expr DOTADD expr  [precedence=left, level=6]
Rule 34    expr -> expr / expr  [precedence=left, level=7]
Rule 35    expr -> expr * expr  [precedence=left, level=7]
Rule 36    expr -> expr - expr  [precedence=left, level=6]
Rule 37    expr -> expr + expr  [precedence=left, level=6]
Rule 38    vector -> <empty>
Rule 39    vector -> expr
Rule 40    vector -> vector , expr
Rule 41    term -> ID
Rule 42    term -> STRING
Rule 43    term -> FLOATNUM
Rule 44    term -> INTNUM
Rule 45    term -> EYE ( expr )
Rule 46    term -> ONES ( vector )
Rule 47    term -> ZEROS ( vector )
Rule 48    term -> term [ vector ]

Terminals, with rules where they appear:

'                    : 27
(                    : 14 15 16 26 45 46 47
)                    : 14 15 16 26 45 46 47
*                    : 35
+                    : 29 37
,                    : 40
-                    : 28 36
/                    : 34
:                    : 13
;                    : 4 5 6 7 8 9 10 11 12
<                    : 25
=                    : 12 13
>                    : 24
ADDASSIGN            : 11
BREAK                : 7
CONTINUE             : 6
DIVASSIGN            : 8
DOTADD               : 33
DOTDIV               : 30
DOTMUL               : 31
DOTSUB               : 32
ELSE                 : 16
EQU                  : 21
EYE                  : 45
FLOATNUM             : 43
FOR                  : 13
GEQ                  : 22
ID                   : 41
IF                   : 15 16
INTNUM               : 44
LEQ                  : 23
MULASSIGN            : 9
NEQ                  : 20
ONES                 : 46
PRINT                : 5
RETURN               : 4
STRING               : 42
SUBASSIGN            : 10
WHILE                : 14
ZEROS                : 47
[                    : 18 48
]                    : 18 48
error                : 
{                    : 17
}                    : 17

Nonterminals, with rules where they appear:

expr                 : 8 9 10 11 12 13 13 14 15 16 20 20 21 21 22 22 23 23 24 24 25 25 26 27 28 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 39 40 45
program              : 0
stmt                 : 2 3 13 14 15 16 16
stmt_set             : 1 2 17
term                 : 8 9 10 11 12 13 19 48
vector               : 4 5 18 40 46 47 48


state 0

    (0) S' -> . program
    (1) program -> . stmt_set
    (2) stmt_set -> . stmt_set stmt
    (3) stmt_set -> . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    program                        shift and go to state 1
    stmt_set                       shift and go to state 2
    stmt                           shift and go to state 3
    term                           shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> stmt_set .
    (2) stmt_set -> stmt_set . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    $end            reduce using rule 1 (program -> stmt_set .)
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt                           shift and go to state 20
    term                           shift and go to state 8

state 3

    (3) stmt_set -> stmt .
    RETURN          reduce using rule 3 (stmt_set -> stmt .)
    PRINT           reduce using rule 3 (stmt_set -> stmt .)
    CONTINUE        reduce using rule 3 (stmt_set -> stmt .)
    BREAK           reduce using rule 3 (stmt_set -> stmt .)
    FOR             reduce using rule 3 (stmt_set -> stmt .)
    WHILE           reduce using rule 3 (stmt_set -> stmt .)
    IF              reduce using rule 3 (stmt_set -> stmt .)
    {               reduce using rule 3 (stmt_set -> stmt .)
    ID              reduce using rule 3 (stmt_set -> stmt .)
    STRING          reduce using rule 3 (stmt_set -> stmt .)
    FLOATNUM        reduce using rule 3 (stmt_set -> stmt .)
    INTNUM          reduce using rule 3 (stmt_set -> stmt .)
    EYE             reduce using rule 3 (stmt_set -> stmt .)
    ONES            reduce using rule 3 (stmt_set -> stmt .)
    ZEROS           reduce using rule 3 (stmt_set -> stmt .)
    $end            reduce using rule 3 (stmt_set -> stmt .)
    }               reduce using rule 3 (stmt_set -> stmt .)


state 4

    (4) stmt -> RETURN . vector ;
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    ;               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    vector                         shift and go to state 21
    expr                           shift and go to state 22
    term                           shift and go to state 24

state 5

    (5) stmt -> PRINT . vector ;
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    ;               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    vector                         shift and go to state 28
    expr                           shift and go to state 22
    term                           shift and go to state 24

state 6

    (6) stmt -> CONTINUE . ;
    ;               shift and go to state 29


state 7

    (7) stmt -> BREAK . ;
    ;               shift and go to state 30


state 8

    (8) stmt -> term . DIVASSIGN expr ;
    (9) stmt -> term . MULASSIGN expr ;
    (10) stmt -> term . SUBASSIGN expr ;
    (11) stmt -> term . ADDASSIGN expr ;
    (12) stmt -> term . = expr ;
    (48) term -> term . [ vector ]
    DIVASSIGN       shift and go to state 31
    MULASSIGN       shift and go to state 32
    SUBASSIGN       shift and go to state 33
    ADDASSIGN       shift and go to state 34
    =               shift and go to state 35
    [               shift and go to state 36


state 9

    (13) stmt -> FOR . term = expr : expr stmt
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 37

state 10

    (14) stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 38


state 11

    (15) stmt -> IF . ( expr ) stmt
    (16) stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 39


state 12

    (17) stmt -> { . stmt_set }
    (2) stmt_set -> . stmt_set stmt
    (3) stmt_set -> . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt_set                       shift and go to state 40
    stmt                           shift and go to state 3
    term                           shift and go to state 8

state 13

    (41) term -> ID .
    DIVASSIGN       reduce using rule 41 (term -> ID .)
    MULASSIGN       reduce using rule 41 (term -> ID .)
    SUBASSIGN       reduce using rule 41 (term -> ID .)
    ADDASSIGN       reduce using rule 41 (term -> ID .)
    =               reduce using rule 41 (term -> ID .)
    [               reduce using rule 41 (term -> ID .)
    NEQ             reduce using rule 41 (term -> ID .)
    EQU             reduce using rule 41 (term -> ID .)
    GEQ             reduce using rule 41 (term -> ID .)
    LEQ             reduce using rule 41 (term -> ID .)
    >               reduce using rule 41 (term -> ID .)
    <               reduce using rule 41 (term -> ID .)
    '               reduce using rule 41 (term -> ID .)
    DOTDIV          reduce using rule 41 (term -> ID .)
    DOTMUL          reduce using rule 41 (term -> ID .)
    DOTSUB          reduce using rule 41 (term -> ID .)
    DOTADD          reduce using rule 41 (term -> ID .)
    /               reduce using rule 41 (term -> ID .)
    *               reduce using rule 41 (term -> ID .)
    -               reduce using rule 41 (term -> ID .)
    +               reduce using rule 41 (term -> ID .)
    ;               reduce using rule 41 (term -> ID .)
    ,               reduce using rule 41 (term -> ID .)
    ]               reduce using rule 41 (term -> ID .)
    )               reduce using rule 41 (term -> ID .)
    :               reduce using rule 41 (term -> ID .)
    RETURN          reduce using rule 41 (term -> ID .)
    PRINT           reduce using rule 41 (term -> ID .)
    CONTINUE        reduce using rule 41 (term -> ID .)
    BREAK           reduce using rule 41 (term -> ID .)
    FOR             reduce using rule 41 (term -> ID .)
    WHILE           reduce using rule 41 (term -> ID .)
    IF              reduce using rule 41 (term -> ID .)
    {               reduce using rule 41 (term -> ID .)
    ID              reduce using rule 41 (term -> ID .)
    STRING          reduce using rule 41 (term -> ID .)
    FLOATNUM        reduce using rule 41 (term -> ID .)
    INTNUM          reduce using rule 41 (term -> ID .)
    EYE             reduce using rule 41 (term -> ID .)
    ONES            reduce using rule 41 (term -> ID .)
    ZEROS           reduce using rule 41 (term -> ID .)


state 14

    (42) term -> STRING .
    DIVASSIGN       reduce using rule 42 (term -> STRING .)
    MULASSIGN       reduce using rule 42 (term -> STRING .)
    SUBASSIGN       reduce using rule 42 (term -> STRING .)
    ADDASSIGN       reduce using rule 42 (term -> STRING .)
    =               reduce using rule 42 (term -> STRING .)
    [               reduce using rule 42 (term -> STRING .)
    NEQ             reduce using rule 42 (term -> STRING .)
    EQU             reduce using rule 42 (term -> STRING .)
    GEQ             reduce using rule 42 (term -> STRING .)
    LEQ             reduce using rule 42 (term -> STRING .)
    >               reduce using rule 42 (term -> STRING .)
    <               reduce using rule 42 (term -> STRING .)
    '               reduce using rule 42 (term -> STRING .)
    DOTDIV          reduce using rule 42 (term -> STRING .)
    DOTMUL          reduce using rule 42 (term -> STRING .)
    DOTSUB          reduce using rule 42 (term -> STRING .)
    DOTADD          reduce using rule 42 (term -> STRING .)
    /               reduce using rule 42 (term -> STRING .)
    *               reduce using rule 42 (term -> STRING .)
    -               reduce using rule 42 (term -> STRING .)
    +               reduce using rule 42 (term -> STRING .)
    ;               reduce using rule 42 (term -> STRING .)
    ,               reduce using rule 42 (term -> STRING .)
    ]               reduce using rule 42 (term -> STRING .)
    )               reduce using rule 42 (term -> STRING .)
    :               reduce using rule 42 (term -> STRING .)
    RETURN          reduce using rule 42 (term -> STRING .)
    PRINT           reduce using rule 42 (term -> STRING .)
    CONTINUE        reduce using rule 42 (term -> STRING .)
    BREAK           reduce using rule 42 (term -> STRING .)
    FOR             reduce using rule 42 (term -> STRING .)
    WHILE           reduce using rule 42 (term -> STRING .)
    IF              reduce using rule 42 (term -> STRING .)
    {               reduce using rule 42 (term -> STRING .)
    ID              reduce using rule 42 (term -> STRING .)
    STRING          reduce using rule 42 (term -> STRING .)
    FLOATNUM        reduce using rule 42 (term -> STRING .)
    INTNUM          reduce using rule 42 (term -> STRING .)
    EYE             reduce using rule 42 (term -> STRING .)
    ONES            reduce using rule 42 (term -> STRING .)
    ZEROS           reduce using rule 42 (term -> STRING .)


state 15

    (43) term -> FLOATNUM .
    DIVASSIGN       reduce using rule 43 (term -> FLOATNUM .)
    MULASSIGN       reduce using rule 43 (term -> FLOATNUM .)
    SUBASSIGN       reduce using rule 43 (term -> FLOATNUM .)
    ADDASSIGN       reduce using rule 43 (term -> FLOATNUM .)
    =               reduce using rule 43 (term -> FLOATNUM .)
    [               reduce using rule 43 (term -> FLOATNUM .)
    NEQ             reduce using rule 43 (term -> FLOATNUM .)
    EQU             reduce using rule 43 (term -> FLOATNUM .)
    GEQ             reduce using rule 43 (term -> FLOATNUM .)
    LEQ             reduce using rule 43 (term -> FLOATNUM .)
    >               reduce using rule 43 (term -> FLOATNUM .)
    <               reduce using rule 43 (term -> FLOATNUM .)
    '               reduce using rule 43 (term -> FLOATNUM .)
    DOTDIV          reduce using rule 43 (term -> FLOATNUM .)
    DOTMUL          reduce using rule 43 (term -> FLOATNUM .)
    DOTSUB          reduce using rule 43 (term -> FLOATNUM .)
    DOTADD          reduce using rule 43 (term -> FLOATNUM .)
    /               reduce using rule 43 (term -> FLOATNUM .)
    *               reduce using rule 43 (term -> FLOATNUM .)
    -               reduce using rule 43 (term -> FLOATNUM .)
    +               reduce using rule 43 (term -> FLOATNUM .)
    ;               reduce using rule 43 (term -> FLOATNUM .)
    ,               reduce using rule 43 (term -> FLOATNUM .)
    ]               reduce using rule 43 (term -> FLOATNUM .)
    )               reduce using rule 43 (term -> FLOATNUM .)
    :               reduce using rule 43 (term -> FLOATNUM .)
    RETURN          reduce using rule 43 (term -> FLOATNUM .)
    PRINT           reduce using rule 43 (term -> FLOATNUM .)
    CONTINUE        reduce using rule 43 (term -> FLOATNUM .)
    BREAK           reduce using rule 43 (term -> FLOATNUM .)
    FOR             reduce using rule 43 (term -> FLOATNUM .)
    WHILE           reduce using rule 43 (term -> FLOATNUM .)
    IF              reduce using rule 43 (term -> FLOATNUM .)
    {               reduce using rule 43 (term -> FLOATNUM .)
    ID              reduce using rule 43 (term -> FLOATNUM .)
    STRING          reduce using rule 43 (term -> FLOATNUM .)
    FLOATNUM        reduce using rule 43 (term -> FLOATNUM .)
    INTNUM          reduce using rule 43 (term -> FLOATNUM .)
    EYE             reduce using rule 43 (term -> FLOATNUM .)
    ONES            reduce using rule 43 (term -> FLOATNUM .)
    ZEROS           reduce using rule 43 (term -> FLOATNUM .)


state 16

    (44) term -> INTNUM .
    DIVASSIGN       reduce using rule 44 (term -> INTNUM .)
    MULASSIGN       reduce using rule 44 (term -> INTNUM .)
    SUBASSIGN       reduce using rule 44 (term -> INTNUM .)
    ADDASSIGN       reduce using rule 44 (term -> INTNUM .)
    =               reduce using rule 44 (term -> INTNUM .)
    [               reduce using rule 44 (term -> INTNUM .)
    NEQ             reduce using rule 44 (term -> INTNUM .)
    EQU             reduce using rule 44 (term -> INTNUM .)
    GEQ             reduce using rule 44 (term -> INTNUM .)
    LEQ             reduce using rule 44 (term -> INTNUM .)
    >               reduce using rule 44 (term -> INTNUM .)
    <               reduce using rule 44 (term -> INTNUM .)
    '               reduce using rule 44 (term -> INTNUM .)
    DOTDIV          reduce using rule 44 (term -> INTNUM .)
    DOTMUL          reduce using rule 44 (term -> INTNUM .)
    DOTSUB          reduce using rule 44 (term -> INTNUM .)
    DOTADD          reduce using rule 44 (term -> INTNUM .)
    /               reduce using rule 44 (term -> INTNUM .)
    *               reduce using rule 44 (term -> INTNUM .)
    -               reduce using rule 44 (term -> INTNUM .)
    +               reduce using rule 44 (term -> INTNUM .)
    ;               reduce using rule 44 (term -> INTNUM .)
    ,               reduce using rule 44 (term -> INTNUM .)
    ]               reduce using rule 44 (term -> INTNUM .)
    )               reduce using rule 44 (term -> INTNUM .)
    :               reduce using rule 44 (term -> INTNUM .)
    RETURN          reduce using rule 44 (term -> INTNUM .)
    PRINT           reduce using rule 44 (term -> INTNUM .)
    CONTINUE        reduce using rule 44 (term -> INTNUM .)
    BREAK           reduce using rule 44 (term -> INTNUM .)
    FOR             reduce using rule 44 (term -> INTNUM .)
    WHILE           reduce using rule 44 (term -> INTNUM .)
    IF              reduce using rule 44 (term -> INTNUM .)
    {               reduce using rule 44 (term -> INTNUM .)
    ID              reduce using rule 44 (term -> INTNUM .)
    STRING          reduce using rule 44 (term -> INTNUM .)
    FLOATNUM        reduce using rule 44 (term -> INTNUM .)
    INTNUM          reduce using rule 44 (term -> INTNUM .)
    EYE             reduce using rule 44 (term -> INTNUM .)
    ONES            reduce using rule 44 (term -> INTNUM .)
    ZEROS           reduce using rule 44 (term -> INTNUM .)


state 17

    (45) term -> EYE . ( expr )
    (               shift and go to state 41


state 18

    (46) term -> ONES . ( vector )
    (               shift and go to state 42


state 19

    (47) term -> ZEROS . ( vector )
    (               shift and go to state 43


state 20

    (2) stmt_set -> stmt_set stmt .
    RETURN          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    PRINT           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    CONTINUE        reduce using rule 2 (stmt_set -> stmt_set stmt .)
    BREAK           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    FOR             reduce using rule 2 (stmt_set -> stmt_set stmt .)
    WHILE           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    IF              reduce using rule 2 (stmt_set -> stmt_set stmt .)
    {               reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ID              reduce using rule 2 (stmt_set -> stmt_set stmt .)
    STRING          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    FLOATNUM        reduce using rule 2 (stmt_set -> stmt_set stmt .)
    INTNUM          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    EYE             reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ONES            reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ZEROS           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    $end            reduce using rule 2 (stmt_set -> stmt_set stmt .)
    }               reduce using rule 2 (stmt_set -> stmt_set stmt .)


state 21

    (4) stmt -> RETURN vector . ;
    (40) vector -> vector . , expr
    ;               shift and go to state 44
    ,               shift and go to state 45


state 22

    (39) vector -> expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 39 (vector -> expr .)
    ,               reduce using rule 39 (vector -> expr .)
    ]               reduce using rule 39 (vector -> expr .)
    )               reduce using rule 39 (vector -> expr .)
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 23

    (18) expr -> [ . vector ]
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    ]               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    vector                         shift and go to state 61
    expr                           shift and go to state 22
    term                           shift and go to state 24

state 24

    (19) expr -> term .
    (48) term -> term . [ vector ]
    NEQ             reduce using rule 19 (expr -> term .)
    EQU             reduce using rule 19 (expr -> term .)
    GEQ             reduce using rule 19 (expr -> term .)
    LEQ             reduce using rule 19 (expr -> term .)
    >               reduce using rule 19 (expr -> term .)
    <               reduce using rule 19 (expr -> term .)
    '               reduce using rule 19 (expr -> term .)
    DOTDIV          reduce using rule 19 (expr -> term .)
    DOTMUL          reduce using rule 19 (expr -> term .)
    DOTSUB          reduce using rule 19 (expr -> term .)
    DOTADD          reduce using rule 19 (expr -> term .)
    /               reduce using rule 19 (expr -> term .)
    *               reduce using rule 19 (expr -> term .)
    -               reduce using rule 19 (expr -> term .)
    +               reduce using rule 19 (expr -> term .)
    ;               reduce using rule 19 (expr -> term .)
    ,               reduce using rule 19 (expr -> term .)
    ]               reduce using rule 19 (expr -> term .)
    )               reduce using rule 19 (expr -> term .)
    :               reduce using rule 19 (expr -> term .)
    RETURN          reduce using rule 19 (expr -> term .)
    PRINT           reduce using rule 19 (expr -> term .)
    CONTINUE        reduce using rule 19 (expr -> term .)
    BREAK           reduce using rule 19 (expr -> term .)
    FOR             reduce using rule 19 (expr -> term .)
    WHILE           reduce using rule 19 (expr -> term .)
    IF              reduce using rule 19 (expr -> term .)
    {               reduce using rule 19 (expr -> term .)
    ID              reduce using rule 19 (expr -> term .)
    STRING          reduce using rule 19 (expr -> term .)
    FLOATNUM        reduce using rule 19 (expr -> term .)
    INTNUM          reduce using rule 19 (expr -> term .)
    EYE             reduce using rule 19 (expr -> term .)
    ONES            reduce using rule 19 (expr -> term .)
    ZEROS           reduce using rule 19 (expr -> term .)
    [               shift and go to state 36


state 25

    (26) expr -> ( . expr )
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 62
    term                           shift and go to state 24

state 26

    (28) expr -> - . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 63
    term                           shift and go to state 24

state 27

    (29) expr -> + . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 64
    term                           shift and go to state 24

state 28

    (5) stmt -> PRINT vector . ;
    (40) vector -> vector . , expr
    ;               shift and go to state 65
    ,               shift and go to state 45


state 29

    (6) stmt -> CONTINUE ; .
    RETURN          reduce using rule 6 (stmt -> CONTINUE ; .)
    PRINT           reduce using rule 6 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 6 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 6 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 6 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 6 (stmt -> CONTINUE ; .)
    IF              reduce using rule 6 (stmt -> CONTINUE ; .)
    {               reduce using rule 6 (stmt -> CONTINUE ; .)
    ID              reduce using rule 6 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 6 (stmt -> CONTINUE ; .)
    FLOATNUM        reduce using rule 6 (stmt -> CONTINUE ; .)
    INTNUM          reduce using rule 6 (stmt -> CONTINUE ; .)
    EYE             reduce using rule 6 (stmt -> CONTINUE ; .)
    ONES            reduce using rule 6 (stmt -> CONTINUE ; .)
    ZEROS           reduce using rule 6 (stmt -> CONTINUE ; .)
    $end            reduce using rule 6 (stmt -> CONTINUE ; .)
    }               reduce using rule 6 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 6 (stmt -> CONTINUE ; .)


state 30

    (7) stmt -> BREAK ; .
    RETURN          reduce using rule 7 (stmt -> BREAK ; .)
    PRINT           reduce using rule 7 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 7 (stmt -> BREAK ; .)
    BREAK           reduce using rule 7 (stmt -> BREAK ; .)
    FOR             reduce using rule 7 (stmt -> BREAK ; .)
    WHILE           reduce using rule 7 (stmt -> BREAK ; .)
    IF              reduce using rule 7 (stmt -> BREAK ; .)
    {               reduce using rule 7 (stmt -> BREAK ; .)
    ID              reduce using rule 7 (stmt -> BREAK ; .)
    STRING          reduce using rule 7 (stmt -> BREAK ; .)
    FLOATNUM        reduce using rule 7 (stmt -> BREAK ; .)
    INTNUM          reduce using rule 7 (stmt -> BREAK ; .)
    EYE             reduce using rule 7 (stmt -> BREAK ; .)
    ONES            reduce using rule 7 (stmt -> BREAK ; .)
    ZEROS           reduce using rule 7 (stmt -> BREAK ; .)
    $end            reduce using rule 7 (stmt -> BREAK ; .)
    }               reduce using rule 7 (stmt -> BREAK ; .)
    ELSE            reduce using rule 7 (stmt -> BREAK ; .)


state 31

    (8) stmt -> term DIVASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 66

state 32

    (9) stmt -> term MULASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 67

state 33

    (10) stmt -> term SUBASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 68

state 34

    (11) stmt -> term ADDASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 69

state 35

    (12) stmt -> term = . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 70

state 36

    (48) term -> term [ . vector ]
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    ]               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    vector                         shift and go to state 71
    expr                           shift and go to state 22

state 37

    (13) stmt -> FOR term . = expr : expr stmt
    (48) term -> term . [ vector ]
    =               shift and go to state 72
    [               shift and go to state 36


state 38

    (14) stmt -> WHILE ( . expr ) stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 73
    term                           shift and go to state 24

state 39

    (15) stmt -> IF ( . expr ) stmt
    (16) stmt -> IF ( . expr ) stmt ELSE stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 74
    term                           shift and go to state 24

state 40

    (17) stmt -> { stmt_set . }
    (2) stmt_set -> stmt_set . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    }               shift and go to state 75
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt                           shift and go to state 20
    term                           shift and go to state 8

state 41

    (45) term -> EYE ( . expr )
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 76
    term                           shift and go to state 24

state 42

    (46) term -> ONES ( . vector )
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    )               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    vector                         shift and go to state 77
    expr                           shift and go to state 22
    term                           shift and go to state 24

state 43

    (47) term -> ZEROS ( . vector )
    (38) vector -> .
    (39) vector -> . expr
    (40) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    )               reduce using rule 38 (vector -> .)
    ,               reduce using rule 38 (vector -> .)
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    vector                         shift and go to state 78
    expr                           shift and go to state 22
    term                           shift and go to state 24

state 44

    (4) stmt -> RETURN vector ; .
    RETURN          reduce using rule 4 (stmt -> RETURN vector ; .)
    PRINT           reduce using rule 4 (stmt -> RETURN vector ; .)
    CONTINUE        reduce using rule 4 (stmt -> RETURN vector ; .)
    BREAK           reduce using rule 4 (stmt -> RETURN vector ; .)
    FOR             reduce using rule 4 (stmt -> RETURN vector ; .)
    WHILE           reduce using rule 4 (stmt -> RETURN vector ; .)
    IF              reduce using rule 4 (stmt -> RETURN vector ; .)
    {               reduce using rule 4 (stmt -> RETURN vector ; .)
    ID              reduce using rule 4 (stmt -> RETURN vector ; .)
    STRING          reduce using rule 4 (stmt -> RETURN vector ; .)
    FLOATNUM        reduce using rule 4 (stmt -> RETURN vector ; .)
    INTNUM          reduce using rule 4 (stmt -> RETURN vector ; .)
    EYE             reduce using rule 4 (stmt -> RETURN vector ; .)
    ONES            reduce using rule 4 (stmt -> RETURN vector ; .)
    ZEROS           reduce using rule 4 (stmt -> RETURN vector ; .)
    $end            reduce using rule 4 (stmt -> RETURN vector ; .)
    }               reduce using rule 4 (stmt -> RETURN vector ; .)
    ELSE            reduce using rule 4 (stmt -> RETURN vector ; .)


state 45

    (40) vector -> vector , . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 79
    term                           shift and go to state 24

state 46

    (20) expr -> expr NEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 80
    term                           shift and go to state 24

state 47

    (21) expr -> expr EQU . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 81
    term                           shift and go to state 24

state 48

    (22) expr -> expr GEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 82
    term                           shift and go to state 24

state 49

    (23) expr -> expr LEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 83
    term                           shift and go to state 24

state 50

    (24) expr -> expr > . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 84
    term                           shift and go to state 24

state 51

    (25) expr -> expr < . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 85
    term                           shift and go to state 24

state 52

    (27) expr -> expr ' .
    NEQ             reduce using rule 27 (expr -> expr ' .)
    EQU             reduce using rule 27 (expr -> expr ' .)
    GEQ             reduce using rule 27 (expr -> expr ' .)
    LEQ             reduce using rule 27 (expr -> expr ' .)
    >               reduce using rule 27 (expr -> expr ' .)
    <               reduce using rule 27 (expr -> expr ' .)
    '               reduce using rule 27 (expr -> expr ' .)
    DOTDIV          reduce using rule 27 (expr -> expr ' .)
    DOTMUL          reduce using rule 27 (expr -> expr ' .)
    DOTSUB          reduce using rule 27 (expr -> expr ' .)
    DOTADD          reduce using rule 27 (expr -> expr ' .)
    /               reduce using rule 27 (expr -> expr ' .)
    *               reduce using rule 27 (expr -> expr ' .)
    -               reduce using rule 27 (expr -> expr ' .)
    +               reduce using rule 27 (expr -> expr ' .)
    ;               reduce using rule 27 (expr -> expr ' .)
    ,               reduce using rule 27 (expr -> expr ' .)
    ]               reduce using rule 27 (expr -> expr ' .)
    )               reduce using rule 27 (expr -> expr ' .)
    :               reduce using rule 27 (expr -> expr ' .)
    RETURN          reduce using rule 27 (expr -> expr ' .)
    PRINT           reduce using rule 27 (expr -> expr ' .)
    CONTINUE        reduce using rule 27 (expr -> expr ' .)
    BREAK           reduce using rule 27 (expr -> expr ' .)
    FOR             reduce using rule 27 (expr -> expr ' .)
    WHILE           reduce using rule 27 (expr -> expr ' .)
    IF              reduce using rule 27 (expr -> expr ' .)
    {               reduce using rule 27 (expr -> expr ' .)
    ID              reduce using rule 27 (expr -> expr ' .)
    STRING          reduce using rule 27 (expr -> expr ' .)
    FLOATNUM        reduce using rule 27 (expr -> expr ' .)
    INTNUM          reduce using rule 27 (expr -> expr ' .)
    EYE             reduce using rule 27 (expr -> expr ' .)
    ONES            reduce using rule 27 (expr -> expr ' .)
    ZEROS           reduce using rule 27 (expr -> expr ' .)


state 53

    (30) expr -> expr DOTDIV . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 86
    term                           shift and go to state 24

state 54

    (31) expr -> expr DOTMUL . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 87
    term                           shift and go to state 24

state 55

    (32) expr -> expr DOTSUB . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 88
    term                           shift and go to state 24

state 56

    (33) expr -> expr DOTADD . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 89
    term                           shift and go to state 24

state 57

    (34) expr -> expr / . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 90
    term                           shift and go to state 24

state 58

    (35) expr -> expr * . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 91
    term                           shift and go to state 24

state 59

    (36) expr -> expr - . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 92
    term                           shift and go to state 24

state 60

    (37) expr -> expr + . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    expr                           shift and go to state 93
    term                           shift and go to state 24

state 61

    (18) expr -> [ vector . ]
    (40) vector -> vector . , expr
    ]               shift and go to state 94
    ,               shift and go to state 45


state 62

    (26) expr -> ( expr . )
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 95
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 63

    (28) expr -> - expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 28 (expr -> - expr .)
    EQU             reduce using rule 28 (expr -> - expr .)
    GEQ             reduce using rule 28 (expr -> - expr .)
    LEQ             reduce using rule 28 (expr -> - expr .)
    >               reduce using rule 28 (expr -> - expr .)
    <               reduce using rule 28 (expr -> - expr .)
    DOTDIV          reduce using rule 28 (expr -> - expr .)
    DOTMUL          reduce using rule 28 (expr -> - expr .)
    DOTSUB          reduce using rule 28 (expr -> - expr .)
    DOTADD          reduce using rule 28 (expr -> - expr .)
    /               reduce using rule 28 (expr -> - expr .)
    *               reduce using rule 28 (expr -> - expr .)
    -               reduce using rule 28 (expr -> - expr .)
    +               reduce using rule 28 (expr -> - expr .)
    ;               reduce using rule 28 (expr -> - expr .)
    ,               reduce using rule 28 (expr -> - expr .)
    ]               reduce using rule 28 (expr -> - expr .)
    )               reduce using rule 28 (expr -> - expr .)
    :               reduce using rule 28 (expr -> - expr .)
    RETURN          reduce using rule 28 (expr -> - expr .)
    PRINT           reduce using rule 28 (expr -> - expr .)
    CONTINUE        reduce using rule 28 (expr -> - expr .)
    BREAK           reduce using rule 28 (expr -> - expr .)
    FOR             reduce using rule 28 (expr -> - expr .)
    WHILE           reduce using rule 28 (expr -> - expr .)
    IF              reduce using rule 28 (expr -> - expr .)
    {               reduce using rule 28 (expr -> - expr .)
    ID              reduce using rule 28 (expr -> - expr .)
    STRING          reduce using rule 28 (expr -> - expr .)
    FLOATNUM        reduce using rule 28 (expr -> - expr .)
    INTNUM          reduce using rule 28 (expr -> - expr .)
    EYE             reduce using rule 28 (expr -> - expr .)
    ONES            reduce using rule 28 (expr -> - expr .)
    ZEROS           reduce using rule 28 (expr -> - expr .)
    '               shift and go to state 52


state 64

    (29) expr -> + expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 29 (expr -> + expr .)
    EQU             reduce using rule 29 (expr -> + expr .)
    GEQ             reduce using rule 29 (expr -> + expr .)
    LEQ             reduce using rule 29 (expr -> + expr .)
    >               reduce using rule 29 (expr -> + expr .)
    <               reduce using rule 29 (expr -> + expr .)
    DOTDIV          reduce using rule 29 (expr -> + expr .)
    DOTMUL          reduce using rule 29 (expr -> + expr .)
    DOTSUB          reduce using rule 29 (expr -> + expr .)
    DOTADD          reduce using rule 29 (expr -> + expr .)
    /               reduce using rule 29 (expr -> + expr .)
    *               reduce using rule 29 (expr -> + expr .)
    -               reduce using rule 29 (expr -> + expr .)
    +               reduce using rule 29 (expr -> + expr .)
    ;               reduce using rule 29 (expr -> + expr .)
    ,               reduce using rule 29 (expr -> + expr .)
    ]               reduce using rule 29 (expr -> + expr .)
    )               reduce using rule 29 (expr -> + expr .)
    :               reduce using rule 29 (expr -> + expr .)
    RETURN          reduce using rule 29 (expr -> + expr .)
    PRINT           reduce using rule 29 (expr -> + expr .)
    CONTINUE        reduce using rule 29 (expr -> + expr .)
    BREAK           reduce using rule 29 (expr -> + expr .)
    FOR             reduce using rule 29 (expr -> + expr .)
    WHILE           reduce using rule 29 (expr -> + expr .)
    IF              reduce using rule 29 (expr -> + expr .)
    {               reduce using rule 29 (expr -> + expr .)
    ID              reduce using rule 29 (expr -> + expr .)
    STRING          reduce using rule 29 (expr -> + expr .)
    FLOATNUM        reduce using rule 29 (expr -> + expr .)
    INTNUM          reduce using rule 29 (expr -> + expr .)
    EYE             reduce using rule 29 (expr -> + expr .)
    ONES            reduce using rule 29 (expr -> + expr .)
    ZEROS           reduce using rule 29 (expr -> + expr .)
    '               shift and go to state 52


state 65

    (5) stmt -> PRINT vector ; .
    RETURN          reduce using rule 5 (stmt -> PRINT vector ; .)
    PRINT           reduce using rule 5 (stmt -> PRINT vector ; .)
    CONTINUE        reduce using rule 5 (stmt -> PRINT vector ; .)
    BREAK           reduce using rule 5 (stmt -> PRINT vector ; .)
    FOR             reduce using rule 5 (stmt -> PRINT vector ; .)
    WHILE           reduce using rule 5 (stmt -> PRINT vector ; .)
    IF              reduce using rule 5 (stmt -> PRINT vector ; .)
    {               reduce using rule 5 (stmt -> PRINT vector ; .)
    ID              reduce using rule 5 (stmt -> PRINT vector ; .)
    STRING          reduce using rule 5 (stmt -> PRINT vector ; .)
    FLOATNUM        reduce using rule 5 (stmt -> PRINT vector ; .)
    INTNUM          reduce using rule 5 (stmt -> PRINT vector ; .)
    EYE             reduce using rule 5 (stmt -> PRINT vector ; .)
    ONES            reduce using rule 5 (stmt -> PRINT vector ; .)
    ZEROS           reduce using rule 5 (stmt -> PRINT vector ; .)
    $end            reduce using rule 5 (stmt -> PRINT vector ; .)
    }               reduce using rule 5 (stmt -> PRINT vector ; .)
    ELSE            reduce using rule 5 (stmt -> PRINT vector ; .)


state 66

    (8) stmt -> term DIVASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 96
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 67

    (9) stmt -> term MULASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 97
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 68

    (10) stmt -> term SUBASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 98
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 69

    (11) stmt -> term ADDASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 99
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 70

    (12) stmt -> term = expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 100
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 71

    (48) term -> term [ vector . ]
    (40) vector -> vector . , expr
    ]               shift and go to state 101
    ,               shift and go to state 45


state 72

    (13) stmt -> FOR term = . expr : expr stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 102

state 73

    (14) stmt -> WHILE ( expr . ) stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 103
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 74

    (15) stmt -> IF ( expr . ) stmt
    (16) stmt -> IF ( expr . ) stmt ELSE stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 104
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 75

    (17) stmt -> { stmt_set } .
    RETURN          reduce using rule 17 (stmt -> { stmt_set } .)
    PRINT           reduce using rule 17 (stmt -> { stmt_set } .)
    CONTINUE        reduce using rule 17 (stmt -> { stmt_set } .)
    BREAK           reduce using rule 17 (stmt -> { stmt_set } .)
    FOR             reduce using rule 17 (stmt -> { stmt_set } .)
    WHILE           reduce using rule 17 (stmt -> { stmt_set } .)
    IF              reduce using rule 17 (stmt -> { stmt_set } .)
    {               reduce using rule 17 (stmt -> { stmt_set } .)
    ID              reduce using rule 17 (stmt -> { stmt_set } .)
    STRING          reduce using rule 17 (stmt -> { stmt_set } .)
    FLOATNUM        reduce using rule 17 (stmt -> { stmt_set } .)
    INTNUM          reduce using rule 17 (stmt -> { stmt_set } .)
    EYE             reduce using rule 17 (stmt -> { stmt_set } .)
    ONES            reduce using rule 17 (stmt -> { stmt_set } .)
    ZEROS           reduce using rule 17 (stmt -> { stmt_set } .)
    $end            reduce using rule 17 (stmt -> { stmt_set } .)
    }               reduce using rule 17 (stmt -> { stmt_set } .)
    ELSE            reduce using rule 17 (stmt -> { stmt_set } .)


state 76

    (45) term -> EYE ( expr . )
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 105
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 77

    (46) term -> ONES ( vector . )
    (40) vector -> vector . , expr
    )               shift and go to state 106
    ,               shift and go to state 45


state 78

    (47) term -> ZEROS ( vector . )
    (40) vector -> vector . , expr
    )               shift and go to state 107
    ,               shift and go to state 45


state 79

    (40) vector -> vector , expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 40 (vector -> vector , expr .)
    ,               reduce using rule 40 (vector -> vector , expr .)
    ]               reduce using rule 40 (vector -> vector , expr .)
    )               reduce using rule 40 (vector -> vector , expr .)
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 80

    (20) expr -> expr NEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 20 (expr -> expr NEQ expr .)
    EQU             reduce using rule 20 (expr -> expr NEQ expr .)
    ;               reduce using rule 20 (expr -> expr NEQ expr .)
    ,               reduce using rule 20 (expr -> expr NEQ expr .)
    ]               reduce using rule 20 (expr -> expr NEQ expr .)
    )               reduce using rule 20 (expr -> expr NEQ expr .)
    :               reduce using rule 20 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 20 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 20 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 20 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 20 (expr -> expr NEQ expr .)
    FOR             reduce using rule 20 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 20 (expr -> expr NEQ expr .)
    IF              reduce using rule 20 (expr -> expr NEQ expr .)
    {               reduce using rule 20 (expr -> expr NEQ expr .)
    ID              reduce using rule 20 (expr -> expr NEQ expr .)
    STRING          reduce using rule 20 (expr -> expr NEQ expr .)
    FLOATNUM        reduce using rule 20 (expr -> expr NEQ expr .)
    INTNUM          reduce using rule 20 (expr -> expr NEQ expr .)
    EYE             reduce using rule 20 (expr -> expr NEQ expr .)
    ONES            reduce using rule 20 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 20 (expr -> expr NEQ expr .)
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 81

    (21) expr -> expr EQU expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 21 (expr -> expr EQU expr .)
    EQU             reduce using rule 21 (expr -> expr EQU expr .)
    ;               reduce using rule 21 (expr -> expr EQU expr .)
    ,               reduce using rule 21 (expr -> expr EQU expr .)
    ]               reduce using rule 21 (expr -> expr EQU expr .)
    )               reduce using rule 21 (expr -> expr EQU expr .)
    :               reduce using rule 21 (expr -> expr EQU expr .)
    RETURN          reduce using rule 21 (expr -> expr EQU expr .)
    PRINT           reduce using rule 21 (expr -> expr EQU expr .)
    CONTINUE        reduce using rule 21 (expr -> expr EQU expr .)
    BREAK           reduce using rule 21 (expr -> expr EQU expr .)
    FOR             reduce using rule 21 (expr -> expr EQU expr .)
    WHILE           reduce using rule 21 (expr -> expr EQU expr .)
    IF              reduce using rule 21 (expr -> expr EQU expr .)
    {               reduce using rule 21 (expr -> expr EQU expr .)
    ID              reduce using rule 21 (expr -> expr EQU expr .)
    STRING          reduce using rule 21 (expr -> expr EQU expr .)
    FLOATNUM        reduce using rule 21 (expr -> expr EQU expr .)
    INTNUM          reduce using rule 21 (expr -> expr EQU expr .)
    EYE             reduce using rule 21 (expr -> expr EQU expr .)
    ONES            reduce using rule 21 (expr -> expr EQU expr .)
    ZEROS           reduce using rule 21 (expr -> expr EQU expr .)
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 82

    (22) expr -> expr GEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    EQU             reduce using rule 22 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    >               reduce using rule 22 (expr -> expr GEQ expr .)
    <               reduce using rule 22 (expr -> expr GEQ expr .)
    ;               reduce using rule 22 (expr -> expr GEQ expr .)
    ,               reduce using rule 22 (expr -> expr GEQ expr .)
    ]               reduce using rule 22 (expr -> expr GEQ expr .)
    )               reduce using rule 22 (expr -> expr GEQ expr .)
    :               reduce using rule 22 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 22 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 22 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 22 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 22 (expr -> expr GEQ expr .)
    FOR             reduce using rule 22 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 22 (expr -> expr GEQ expr .)
    IF              reduce using rule 22 (expr -> expr GEQ expr .)
    {               reduce using rule 22 (expr -> expr GEQ expr .)
    ID              reduce using rule 22 (expr -> expr GEQ expr .)
    STRING          reduce using rule 22 (expr -> expr GEQ expr .)
    FLOATNUM        reduce using rule 22 (expr -> expr GEQ expr .)
    INTNUM          reduce using rule 22 (expr -> expr GEQ expr .)
    EYE             reduce using rule 22 (expr -> expr GEQ expr .)
    ONES            reduce using rule 22 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 22 (expr -> expr GEQ expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 83

    (23) expr -> expr LEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    EQU             reduce using rule 23 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    >               reduce using rule 23 (expr -> expr LEQ expr .)
    <               reduce using rule 23 (expr -> expr LEQ expr .)
    ;               reduce using rule 23 (expr -> expr LEQ expr .)
    ,               reduce using rule 23 (expr -> expr LEQ expr .)
    ]               reduce using rule 23 (expr -> expr LEQ expr .)
    )               reduce using rule 23 (expr -> expr LEQ expr .)
    :               reduce using rule 23 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 23 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 23 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 23 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 23 (expr -> expr LEQ expr .)
    FOR             reduce using rule 23 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 23 (expr -> expr LEQ expr .)
    IF              reduce using rule 23 (expr -> expr LEQ expr .)
    {               reduce using rule 23 (expr -> expr LEQ expr .)
    ID              reduce using rule 23 (expr -> expr LEQ expr .)
    STRING          reduce using rule 23 (expr -> expr LEQ expr .)
    FLOATNUM        reduce using rule 23 (expr -> expr LEQ expr .)
    INTNUM          reduce using rule 23 (expr -> expr LEQ expr .)
    EYE             reduce using rule 23 (expr -> expr LEQ expr .)
    ONES            reduce using rule 23 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 23 (expr -> expr LEQ expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 84

    (24) expr -> expr > expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 24 (expr -> expr > expr .)
    EQU             reduce using rule 24 (expr -> expr > expr .)
    GEQ             reduce using rule 24 (expr -> expr > expr .)
    LEQ             reduce using rule 24 (expr -> expr > expr .)
    >               reduce using rule 24 (expr -> expr > expr .)
    <               reduce using rule 24 (expr -> expr > expr .)
    ;               reduce using rule 24 (expr -> expr > expr .)
    ,               reduce using rule 24 (expr -> expr > expr .)
    ]               reduce using rule 24 (expr -> expr > expr .)
    )               reduce using rule 24 (expr -> expr > expr .)
    :               reduce using rule 24 (expr -> expr > expr .)
    RETURN          reduce using rule 24 (expr -> expr > expr .)
    PRINT           reduce using rule 24 (expr -> expr > expr .)
    CONTINUE        reduce using rule 24 (expr -> expr > expr .)
    BREAK           reduce using rule 24 (expr -> expr > expr .)
    FOR             reduce using rule 24 (expr -> expr > expr .)
    WHILE           reduce using rule 24 (expr -> expr > expr .)
    IF              reduce using rule 24 (expr -> expr > expr .)
    {               reduce using rule 24 (expr -> expr > expr .)
    ID              reduce using rule 24 (expr -> expr > expr .)
    STRING          reduce using rule 24 (expr -> expr > expr .)
    FLOATNUM        reduce using rule 24 (expr -> expr > expr .)
    INTNUM          reduce using rule 24 (expr -> expr > expr .)
    EYE             reduce using rule 24 (expr -> expr > expr .)
    ONES            reduce using rule 24 (expr -> expr > expr .)
    ZEROS           reduce using rule 24 (expr -> expr > expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 85

    (25) expr -> expr < expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 25 (expr -> expr < expr .)
    EQU             reduce using rule 25 (expr -> expr < expr .)
    GEQ             reduce using rule 25 (expr -> expr < expr .)
    LEQ             reduce using rule 25 (expr -> expr < expr .)
    >               reduce using rule 25 (expr -> expr < expr .)
    <               reduce using rule 25 (expr -> expr < expr .)
    ;               reduce using rule 25 (expr -> expr < expr .)
    ,               reduce using rule 25 (expr -> expr < expr .)
    ]               reduce using rule 25 (expr -> expr < expr .)
    )               reduce using rule 25 (expr -> expr < expr .)
    :               reduce using rule 25 (expr -> expr < expr .)
    RETURN          reduce using rule 25 (expr -> expr < expr .)
    PRINT           reduce using rule 25 (expr -> expr < expr .)
    CONTINUE        reduce using rule 25 (expr -> expr < expr .)
    BREAK           reduce using rule 25 (expr -> expr < expr .)
    FOR             reduce using rule 25 (expr -> expr < expr .)
    WHILE           reduce using rule 25 (expr -> expr < expr .)
    IF              reduce using rule 25 (expr -> expr < expr .)
    {               reduce using rule 25 (expr -> expr < expr .)
    ID              reduce using rule 25 (expr -> expr < expr .)
    STRING          reduce using rule 25 (expr -> expr < expr .)
    FLOATNUM        reduce using rule 25 (expr -> expr < expr .)
    INTNUM          reduce using rule 25 (expr -> expr < expr .)
    EYE             reduce using rule 25 (expr -> expr < expr .)
    ONES            reduce using rule 25 (expr -> expr < expr .)
    ZEROS           reduce using rule 25 (expr -> expr < expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 86

    (30) expr -> expr DOTDIV expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 30 (expr -> expr DOTDIV expr .)
    EQU             reduce using rule 30 (expr -> expr DOTDIV expr .)
    GEQ             reduce using rule 30 (expr -> expr DOTDIV expr .)
    LEQ             reduce using rule 30 (expr -> expr DOTDIV expr .)
    >               reduce using rule 30 (expr -> expr DOTDIV expr .)
    <               reduce using rule 30 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 30 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 30 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 30 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 30 (expr -> expr DOTDIV expr .)
    /               reduce using rule 30 (expr -> expr DOTDIV expr .)
    *               reduce using rule 30 (expr -> expr DOTDIV expr .)
    -               reduce using rule 30 (expr -> expr DOTDIV expr .)
    +               reduce using rule 30 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 30 (expr -> expr DOTDIV expr .)
    ,               reduce using rule 30 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 30 (expr -> expr DOTDIV expr .)
    )               reduce using rule 30 (expr -> expr DOTDIV expr .)
    :               reduce using rule 30 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 30 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 30 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 30 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 30 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 30 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 30 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 30 (expr -> expr DOTDIV expr .)
    {               reduce using rule 30 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 30 (expr -> expr DOTDIV expr .)
    STRING          reduce using rule 30 (expr -> expr DOTDIV expr .)
    FLOATNUM        reduce using rule 30 (expr -> expr DOTDIV expr .)
    INTNUM          reduce using rule 30 (expr -> expr DOTDIV expr .)
    EYE             reduce using rule 30 (expr -> expr DOTDIV expr .)
    ONES            reduce using rule 30 (expr -> expr DOTDIV expr .)
    ZEROS           reduce using rule 30 (expr -> expr DOTDIV expr .)
    '               shift and go to state 52


state 87

    (31) expr -> expr DOTMUL expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 31 (expr -> expr DOTMUL expr .)
    EQU             reduce using rule 31 (expr -> expr DOTMUL expr .)
    GEQ             reduce using rule 31 (expr -> expr DOTMUL expr .)
    LEQ             reduce using rule 31 (expr -> expr DOTMUL expr .)
    >               reduce using rule 31 (expr -> expr DOTMUL expr .)
    <               reduce using rule 31 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 31 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 31 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 31 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 31 (expr -> expr DOTMUL expr .)
    /               reduce using rule 31 (expr -> expr DOTMUL expr .)
    *               reduce using rule 31 (expr -> expr DOTMUL expr .)
    -               reduce using rule 31 (expr -> expr DOTMUL expr .)
    +               reduce using rule 31 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 31 (expr -> expr DOTMUL expr .)
    ,               reduce using rule 31 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 31 (expr -> expr DOTMUL expr .)
    )               reduce using rule 31 (expr -> expr DOTMUL expr .)
    :               reduce using rule 31 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 31 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 31 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 31 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 31 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 31 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 31 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 31 (expr -> expr DOTMUL expr .)
    {               reduce using rule 31 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 31 (expr -> expr DOTMUL expr .)
    STRING          reduce using rule 31 (expr -> expr DOTMUL expr .)
    FLOATNUM        reduce using rule 31 (expr -> expr DOTMUL expr .)
    INTNUM          reduce using rule 31 (expr -> expr DOTMUL expr .)
    EYE             reduce using rule 31 (expr -> expr DOTMUL expr .)
    ONES            reduce using rule 31 (expr -> expr DOTMUL expr .)
    ZEROS           reduce using rule 31 (expr -> expr DOTMUL expr .)
    '               shift and go to state 52


state 88

    (32) expr -> expr DOTSUB expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 32 (expr -> expr DOTSUB expr .)
    EQU             reduce using rule 32 (expr -> expr DOTSUB expr .)
    GEQ             reduce using rule 32 (expr -> expr DOTSUB expr .)
    LEQ             reduce using rule 32 (expr -> expr DOTSUB expr .)
    >               reduce using rule 32 (expr -> expr DOTSUB expr .)
    <               reduce using rule 32 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 32 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 32 (expr -> expr DOTSUB expr .)
    -               reduce using rule 32 (expr -> expr DOTSUB expr .)
    +               reduce using rule 32 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 32 (expr -> expr DOTSUB expr .)
    ,               reduce using rule 32 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 32 (expr -> expr DOTSUB expr .)
    )               reduce using rule 32 (expr -> expr DOTSUB expr .)
    :               reduce using rule 32 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 32 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 32 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 32 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 32 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 32 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 32 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 32 (expr -> expr DOTSUB expr .)
    {               reduce using rule 32 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 32 (expr -> expr DOTSUB expr .)
    STRING          reduce using rule 32 (expr -> expr DOTSUB expr .)
    FLOATNUM        reduce using rule 32 (expr -> expr DOTSUB expr .)
    INTNUM          reduce using rule 32 (expr -> expr DOTSUB expr .)
    EYE             reduce using rule 32 (expr -> expr DOTSUB expr .)
    ONES            reduce using rule 32 (expr -> expr DOTSUB expr .)
    ZEROS           reduce using rule 32 (expr -> expr DOTSUB expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    /               shift and go to state 57
    *               shift and go to state 58


state 89

    (33) expr -> expr DOTADD expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 33 (expr -> expr DOTADD expr .)
    EQU             reduce using rule 33 (expr -> expr DOTADD expr .)
    GEQ             reduce using rule 33 (expr -> expr DOTADD expr .)
    LEQ             reduce using rule 33 (expr -> expr DOTADD expr .)
    >               reduce using rule 33 (expr -> expr DOTADD expr .)
    <               reduce using rule 33 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 33 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 33 (expr -> expr DOTADD expr .)
    -               reduce using rule 33 (expr -> expr DOTADD expr .)
    +               reduce using rule 33 (expr -> expr DOTADD expr .)
    ;               reduce using rule 33 (expr -> expr DOTADD expr .)
    ,               reduce using rule 33 (expr -> expr DOTADD expr .)
    ]               reduce using rule 33 (expr -> expr DOTADD expr .)
    )               reduce using rule 33 (expr -> expr DOTADD expr .)
    :               reduce using rule 33 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 33 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 33 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 33 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 33 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 33 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 33 (expr -> expr DOTADD expr .)
    IF              reduce using rule 33 (expr -> expr DOTADD expr .)
    {               reduce using rule 33 (expr -> expr DOTADD expr .)
    ID              reduce using rule 33 (expr -> expr DOTADD expr .)
    STRING          reduce using rule 33 (expr -> expr DOTADD expr .)
    FLOATNUM        reduce using rule 33 (expr -> expr DOTADD expr .)
    INTNUM          reduce using rule 33 (expr -> expr DOTADD expr .)
    EYE             reduce using rule 33 (expr -> expr DOTADD expr .)
    ONES            reduce using rule 33 (expr -> expr DOTADD expr .)
    ZEROS           reduce using rule 33 (expr -> expr DOTADD expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    /               shift and go to state 57
    *               shift and go to state 58


state 90

    (34) expr -> expr / expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 34 (expr -> expr / expr .)
    EQU             reduce using rule 34 (expr -> expr / expr .)
    GEQ             reduce using rule 34 (expr -> expr / expr .)
    LEQ             reduce using rule 34 (expr -> expr / expr .)
    >               reduce using rule 34 (expr -> expr / expr .)
    <               reduce using rule 34 (expr -> expr / expr .)
    DOTDIV          reduce using rule 34 (expr -> expr / expr .)
    DOTMUL          reduce using rule 34 (expr -> expr / expr .)
    DOTSUB          reduce using rule 34 (expr -> expr / expr .)
    DOTADD          reduce using rule 34 (expr -> expr / expr .)
    /               reduce using rule 34 (expr -> expr / expr .)
    *               reduce using rule 34 (expr -> expr / expr .)
    -               reduce using rule 34 (expr -> expr / expr .)
    +               reduce using rule 34 (expr -> expr / expr .)
    ;               reduce using rule 34 (expr -> expr / expr .)
    ,               reduce using rule 34 (expr -> expr / expr .)
    ]               reduce using rule 34 (expr -> expr / expr .)
    )               reduce using rule 34 (expr -> expr / expr .)
    :               reduce using rule 34 (expr -> expr / expr .)
    RETURN          reduce using rule 34 (expr -> expr / expr .)
    PRINT           reduce using rule 34 (expr -> expr / expr .)
    CONTINUE        reduce using rule 34 (expr -> expr / expr .)
    BREAK           reduce using rule 34 (expr -> expr / expr .)
    FOR             reduce using rule 34 (expr -> expr / expr .)
    WHILE           reduce using rule 34 (expr -> expr / expr .)
    IF              reduce using rule 34 (expr -> expr / expr .)
    {               reduce using rule 34 (expr -> expr / expr .)
    ID              reduce using rule 34 (expr -> expr / expr .)
    STRING          reduce using rule 34 (expr -> expr / expr .)
    FLOATNUM        reduce using rule 34 (expr -> expr / expr .)
    INTNUM          reduce using rule 34 (expr -> expr / expr .)
    EYE             reduce using rule 34 (expr -> expr / expr .)
    ONES            reduce using rule 34 (expr -> expr / expr .)
    ZEROS           reduce using rule 34 (expr -> expr / expr .)
    '               shift and go to state 52


state 91

    (35) expr -> expr * expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 35 (expr -> expr * expr .)
    EQU             reduce using rule 35 (expr -> expr * expr .)
    GEQ             reduce using rule 35 (expr -> expr * expr .)
    LEQ             reduce using rule 35 (expr -> expr * expr .)
    >               reduce using rule 35 (expr -> expr * expr .)
    <               reduce using rule 35 (expr -> expr * expr .)
    DOTDIV          reduce using rule 35 (expr -> expr * expr .)
    DOTMUL          reduce using rule 35 (expr -> expr * expr .)
    DOTSUB          reduce using rule 35 (expr -> expr * expr .)
    DOTADD          reduce using rule 35 (expr -> expr * expr .)
    /               reduce using rule 35 (expr -> expr * expr .)
    *               reduce using rule 35 (expr -> expr * expr .)
    -               reduce using rule 35 (expr -> expr * expr .)
    +               reduce using rule 35 (expr -> expr * expr .)
    ;               reduce using rule 35 (expr -> expr * expr .)
    ,               reduce using rule 35 (expr -> expr * expr .)
    ]               reduce using rule 35 (expr -> expr * expr .)
    )               reduce using rule 35 (expr -> expr * expr .)
    :               reduce using rule 35 (expr -> expr * expr .)
    RETURN          reduce using rule 35 (expr -> expr * expr .)
    PRINT           reduce using rule 35 (expr -> expr * expr .)
    CONTINUE        reduce using rule 35 (expr -> expr * expr .)
    BREAK           reduce using rule 35 (expr -> expr * expr .)
    FOR             reduce using rule 35 (expr -> expr * expr .)
    WHILE           reduce using rule 35 (expr -> expr * expr .)
    IF              reduce using rule 35 (expr -> expr * expr .)
    {               reduce using rule 35 (expr -> expr * expr .)
    ID              reduce using rule 35 (expr -> expr * expr .)
    STRING          reduce using rule 35 (expr -> expr * expr .)
    FLOATNUM        reduce using rule 35 (expr -> expr * expr .)
    INTNUM          reduce using rule 35 (expr -> expr * expr .)
    EYE             reduce using rule 35 (expr -> expr * expr .)
    ONES            reduce using rule 35 (expr -> expr * expr .)
    ZEROS           reduce using rule 35 (expr -> expr * expr .)
    '               shift and go to state 52


state 92

    (36) expr -> expr - expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 36 (expr -> expr - expr .)
    EQU             reduce using rule 36 (expr -> expr - expr .)
    GEQ             reduce using rule 36 (expr -> expr - expr .)
    LEQ             reduce using rule 36 (expr -> expr - expr .)
    >               reduce using rule 36 (expr -> expr - expr .)
    <               reduce using rule 36 (expr -> expr - expr .)
    DOTSUB          reduce using rule 36 (expr -> expr - expr .)
    DOTADD          reduce using rule 36 (expr -> expr - expr .)
    -               reduce using rule 36 (expr -> expr - expr .)
    +               reduce using rule 36 (expr -> expr - expr .)
    ;               reduce using rule 36 (expr -> expr - expr .)
    ,               reduce using rule 36 (expr -> expr - expr .)
    ]               reduce using rule 36 (expr -> expr - expr .)
    )               reduce using rule 36 (expr -> expr - expr .)
    :               reduce using rule 36 (expr -> expr - expr .)
    RETURN          reduce using rule 36 (expr -> expr - expr .)
    PRINT           reduce using rule 36 (expr -> expr - expr .)
    CONTINUE        reduce using rule 36 (expr -> expr - expr .)
    BREAK           reduce using rule 36 (expr -> expr - expr .)
    FOR             reduce using rule 36 (expr -> expr - expr .)
    WHILE           reduce using rule 36 (expr -> expr - expr .)
    IF              reduce using rule 36 (expr -> expr - expr .)
    {               reduce using rule 36 (expr -> expr - expr .)
    ID              reduce using rule 36 (expr -> expr - expr .)
    STRING          reduce using rule 36 (expr -> expr - expr .)
    FLOATNUM        reduce using rule 36 (expr -> expr - expr .)
    INTNUM          reduce using rule 36 (expr -> expr - expr .)
    EYE             reduce using rule 36 (expr -> expr - expr .)
    ONES            reduce using rule 36 (expr -> expr - expr .)
    ZEROS           reduce using rule 36 (expr -> expr - expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    /               shift and go to state 57
    *               shift and go to state 58


state 93

    (37) expr -> expr + expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    NEQ             reduce using rule 37 (expr -> expr + expr .)
    EQU             reduce using rule 37 (expr -> expr + expr .)
    GEQ             reduce using rule 37 (expr -> expr + expr .)
    LEQ             reduce using rule 37 (expr -> expr + expr .)
    >               reduce using rule 37 (expr -> expr + expr .)
    <               reduce using rule 37 (expr -> expr + expr .)
    DOTSUB          reduce using rule 37 (expr -> expr + expr .)
    DOTADD          reduce using rule 37 (expr -> expr + expr .)
    -               reduce using rule 37 (expr -> expr + expr .)
    +               reduce using rule 37 (expr -> expr + expr .)
    ;               reduce using rule 37 (expr -> expr + expr .)
    ,               reduce using rule 37 (expr -> expr + expr .)
    ]               reduce using rule 37 (expr -> expr + expr .)
    )               reduce using rule 37 (expr -> expr + expr .)
    :               reduce using rule 37 (expr -> expr + expr .)
    RETURN          reduce using rule 37 (expr -> expr + expr .)
    PRINT           reduce using rule 37 (expr -> expr + expr .)
    CONTINUE        reduce using rule 37 (expr -> expr + expr .)
    BREAK           reduce using rule 37 (expr -> expr + expr .)
    FOR             reduce using rule 37 (expr -> expr + expr .)
    WHILE           reduce using rule 37 (expr -> expr + expr .)
    IF              reduce using rule 37 (expr -> expr + expr .)
    {               reduce using rule 37 (expr -> expr + expr .)
    ID              reduce using rule 37 (expr -> expr + expr .)
    STRING          reduce using rule 37 (expr -> expr + expr .)
    FLOATNUM        reduce using rule 37 (expr -> expr + expr .)
    INTNUM          reduce using rule 37 (expr -> expr + expr .)
    EYE             reduce using rule 37 (expr -> expr + expr .)
    ONES            reduce using rule 37 (expr -> expr + expr .)
    ZEROS           reduce using rule 37 (expr -> expr + expr .)
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    /               shift and go to state 57
    *               shift and go to state 58


state 94

    (18) expr -> [ vector ] .
    NEQ             reduce using rule 18 (expr -> [ vector ] .)
    EQU             reduce using rule 18 (expr -> [ vector ] .)
    GEQ             reduce using rule 18 (expr -> [ vector ] .)
    LEQ             reduce using rule 18 (expr -> [ vector ] .)
    >               reduce using rule 18 (expr -> [ vector ] .)
    <               reduce using rule 18 (expr -> [ vector ] .)
    '               reduce using rule 18 (expr -> [ vector ] .)
    DOTDIV          reduce using rule 18 (expr -> [ vector ] .)
    DOTMUL          reduce using rule 18 (expr -> [ vector ] .)
    DOTSUB          reduce using rule 18 (expr -> [ vector ] .)
    DOTADD          reduce using rule 18 (expr -> [ vector ] .)
    /               reduce using rule 18 (expr -> [ vector ] .)
    *               reduce using rule 18 (expr -> [ vector ] .)
    -               reduce using rule 18 (expr -> [ vector ] .)
    +               reduce using rule 18 (expr -> [ vector ] .)
    ;               reduce using rule 18 (expr -> [ vector ] .)
    ,               reduce using rule 18 (expr -> [ vector ] .)
    ]               reduce using rule 18 (expr -> [ vector ] .)
    )               reduce using rule 18 (expr -> [ vector ] .)
    :               reduce using rule 18 (expr -> [ vector ] .)
    RETURN          reduce using rule 18 (expr -> [ vector ] .)
    PRINT           reduce using rule 18 (expr -> [ vector ] .)
    CONTINUE        reduce using rule 18 (expr -> [ vector ] .)
    BREAK           reduce using rule 18 (expr -> [ vector ] .)
    FOR             reduce using rule 18 (expr -> [ vector ] .)
    WHILE           reduce using rule 18 (expr -> [ vector ] .)
    IF              reduce using rule 18 (expr -> [ vector ] .)
    {               reduce using rule 18 (expr -> [ vector ] .)
    ID              reduce using rule 18 (expr -> [ vector ] .)
    STRING          reduce using rule 18 (expr -> [ vector ] .)
    FLOATNUM        reduce using rule 18 (expr -> [ vector ] .)
    INTNUM          reduce using rule 18 (expr -> [ vector ] .)
    EYE             reduce using rule 18 (expr -> [ vector ] .)
    ONES            reduce using rule 18 (expr -> [ vector ] .)
    ZEROS           reduce using rule 18 (expr -> [ vector ] .)


state 95

    (26) expr -> ( expr ) .
    NEQ             reduce using rule 26 (expr -> ( expr ) .)
    EQU             reduce using rule 26 (expr -> ( expr ) .)
    GEQ             reduce using rule 26 (expr -> ( expr ) .)
    LEQ             reduce using rule 26 (expr -> ( expr ) .)
    >               reduce using rule 26 (expr -> ( expr ) .)
    <               reduce using rule 26 (expr -> ( expr ) .)
    '               reduce using rule 26 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 26 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 26 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 26 (expr -> ( expr ) .)
    DOTADD          reduce using rule 26 (expr -> ( expr ) .)
    /               reduce using rule 26 (expr -> ( expr ) .)
    *               reduce using rule 26 (expr -> ( expr ) .)
    -               reduce using rule 26 (expr -> ( expr ) .)
    +               reduce using rule 26 (expr -> ( expr ) .)
    ;               reduce using rule 26 (expr -> ( expr ) .)
    ,               reduce using rule 26 (expr -> ( expr ) .)
    ]               reduce using rule 26 (expr -> ( expr ) .)
    )               reduce using rule 26 (expr -> ( expr ) .)
    :               reduce using rule 26 (expr -> ( expr ) .)
    RETURN          reduce using rule 26 (expr -> ( expr ) .)
    PRINT           reduce using rule 26 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> ( expr ) .)
    BREAK           reduce using rule 26 (expr -> ( expr ) .)
    FOR             reduce using rule 26 (expr -> ( expr ) .)
    WHILE           reduce using rule 26 (expr -> ( expr ) .)
    IF              reduce using rule 26 (expr -> ( expr ) .)
    {               reduce using rule 26 (expr -> ( expr ) .)
    ID              reduce using rule 26 (expr -> ( expr ) .)
    STRING          reduce using rule 26 (expr -> ( expr ) .)
    FLOATNUM        reduce using rule 26 (expr -> ( expr ) .)
    INTNUM          reduce using rule 26 (expr -> ( expr ) .)
    EYE             reduce using rule 26 (expr -> ( expr ) .)
    ONES            reduce using rule 26 (expr -> ( expr ) .)
    ZEROS           reduce using rule 26 (expr -> ( expr ) .)


state 96

    (8) stmt -> term DIVASSIGN expr ; .
    RETURN          reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    PRINT           reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    CONTINUE        reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    BREAK           reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    FOR             reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    WHILE           reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    IF              reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    {               reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    ID              reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    STRING          reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    FLOATNUM        reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    INTNUM          reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    EYE             reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    ONES            reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    ZEROS           reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    $end            reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    }               reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)
    ELSE            reduce using rule 8 (stmt -> term DIVASSIGN expr ; .)


state 97

    (9) stmt -> term MULASSIGN expr ; .
    RETURN          reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    PRINT           reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    CONTINUE        reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    BREAK           reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    FOR             reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    WHILE           reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    IF              reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    {               reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    ID              reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    STRING          reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    FLOATNUM        reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    INTNUM          reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    EYE             reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    ONES            reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    ZEROS           reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    $end            reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    }               reduce using rule 9 (stmt -> term MULASSIGN expr ; .)
    ELSE            reduce using rule 9 (stmt -> term MULASSIGN expr ; .)


state 98

    (10) stmt -> term SUBASSIGN expr ; .
    RETURN          reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    PRINT           reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    CONTINUE        reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    BREAK           reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    FOR             reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    WHILE           reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    IF              reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    {               reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    ID              reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    STRING          reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    FLOATNUM        reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    INTNUM          reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    EYE             reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    ONES            reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    ZEROS           reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    $end            reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    }               reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)
    ELSE            reduce using rule 10 (stmt -> term SUBASSIGN expr ; .)


state 99

    (11) stmt -> term ADDASSIGN expr ; .
    RETURN          reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    PRINT           reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    CONTINUE        reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    BREAK           reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    FOR             reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    WHILE           reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    IF              reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    {               reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    ID              reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    STRING          reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    FLOATNUM        reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    INTNUM          reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    EYE             reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    ONES            reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    ZEROS           reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    $end            reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    }               reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)
    ELSE            reduce using rule 11 (stmt -> term ADDASSIGN expr ; .)


state 100

    (12) stmt -> term = expr ; .
    RETURN          reduce using rule 12 (stmt -> term = expr ; .)
    PRINT           reduce using rule 12 (stmt -> term = expr ; .)
    CONTINUE        reduce using rule 12 (stmt -> term = expr ; .)
    BREAK           reduce using rule 12 (stmt -> term = expr ; .)
    FOR             reduce using rule 12 (stmt -> term = expr ; .)
    WHILE           reduce using rule 12 (stmt -> term = expr ; .)
    IF              reduce using rule 12 (stmt -> term = expr ; .)
    {               reduce using rule 12 (stmt -> term = expr ; .)
    ID              reduce using rule 12 (stmt -> term = expr ; .)
    STRING          reduce using rule 12 (stmt -> term = expr ; .)
    FLOATNUM        reduce using rule 12 (stmt -> term = expr ; .)
    INTNUM          reduce using rule 12 (stmt -> term = expr ; .)
    EYE             reduce using rule 12 (stmt -> term = expr ; .)
    ONES            reduce using rule 12 (stmt -> term = expr ; .)
    ZEROS           reduce using rule 12 (stmt -> term = expr ; .)
    $end            reduce using rule 12 (stmt -> term = expr ; .)
    }               reduce using rule 12 (stmt -> term = expr ; .)
    ELSE            reduce using rule 12 (stmt -> term = expr ; .)


state 101

    (48) term -> term [ vector ] .
    DIVASSIGN       reduce using rule 48 (term -> term [ vector ] .)
    MULASSIGN       reduce using rule 48 (term -> term [ vector ] .)
    SUBASSIGN       reduce using rule 48 (term -> term [ vector ] .)
    ADDASSIGN       reduce using rule 48 (term -> term [ vector ] .)
    =               reduce using rule 48 (term -> term [ vector ] .)
    [               reduce using rule 48 (term -> term [ vector ] .)
    NEQ             reduce using rule 48 (term -> term [ vector ] .)
    EQU             reduce using rule 48 (term -> term [ vector ] .)
    GEQ             reduce using rule 48 (term -> term [ vector ] .)
    LEQ             reduce using rule 48 (term -> term [ vector ] .)
    >               reduce using rule 48 (term -> term [ vector ] .)
    <               reduce using rule 48 (term -> term [ vector ] .)
    '               reduce using rule 48 (term -> term [ vector ] .)
    DOTDIV          reduce using rule 48 (term -> term [ vector ] .)
    DOTMUL          reduce using rule 48 (term -> term [ vector ] .)
    DOTSUB          reduce using rule 48 (term -> term [ vector ] .)
    DOTADD          reduce using rule 48 (term -> term [ vector ] .)
    /               reduce using rule 48 (term -> term [ vector ] .)
    *               reduce using rule 48 (term -> term [ vector ] .)
    -               reduce using rule 48 (term -> term [ vector ] .)
    +               reduce using rule 48 (term -> term [ vector ] .)
    ;               reduce using rule 48 (term -> term [ vector ] .)
    ,               reduce using rule 48 (term -> term [ vector ] .)
    ]               reduce using rule 48 (term -> term [ vector ] .)
    )               reduce using rule 48 (term -> term [ vector ] .)
    :               reduce using rule 48 (term -> term [ vector ] .)
    RETURN          reduce using rule 48 (term -> term [ vector ] .)
    PRINT           reduce using rule 48 (term -> term [ vector ] .)
    CONTINUE        reduce using rule 48 (term -> term [ vector ] .)
    BREAK           reduce using rule 48 (term -> term [ vector ] .)
    FOR             reduce using rule 48 (term -> term [ vector ] .)
    WHILE           reduce using rule 48 (term -> term [ vector ] .)
    IF              reduce using rule 48 (term -> term [ vector ] .)
    {               reduce using rule 48 (term -> term [ vector ] .)
    ID              reduce using rule 48 (term -> term [ vector ] .)
    STRING          reduce using rule 48 (term -> term [ vector ] .)
    FLOATNUM        reduce using rule 48 (term -> term [ vector ] .)
    INTNUM          reduce using rule 48 (term -> term [ vector ] .)
    EYE             reduce using rule 48 (term -> term [ vector ] .)
    ONES            reduce using rule 48 (term -> term [ vector ] .)
    ZEROS           reduce using rule 48 (term -> term [ vector ] .)


state 102

    (13) stmt -> FOR term = expr . : expr stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    :               shift and go to state 108
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60


state 103

    (14) stmt -> WHILE ( expr ) . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt                           shift and go to state 109
    term                           shift and go to state 8

state 104

    (15) stmt -> IF ( expr ) . stmt
    (16) stmt -> IF ( expr ) . stmt ELSE stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt                           shift and go to state 110
    term                           shift and go to state 8

state 105

    (45) term -> EYE ( expr ) .
    DIVASSIGN       reduce using rule 45 (term -> EYE ( expr ) .)
    MULASSIGN       reduce using rule 45 (term -> EYE ( expr ) .)
    SUBASSIGN       reduce using rule 45 (term -> EYE ( expr ) .)
    ADDASSIGN       reduce using rule 45 (term -> EYE ( expr ) .)
    =               reduce using rule 45 (term -> EYE ( expr ) .)
    [               reduce using rule 45 (term -> EYE ( expr ) .)
    NEQ             reduce using rule 45 (term -> EYE ( expr ) .)
    EQU             reduce using rule 45 (term -> EYE ( expr ) .)
    GEQ             reduce using rule 45 (term -> EYE ( expr ) .)
    LEQ             reduce using rule 45 (term -> EYE ( expr ) .)
    >               reduce using rule 45 (term -> EYE ( expr ) .)
    <               reduce using rule 45 (term -> EYE ( expr ) .)
    '               reduce using rule 45 (term -> EYE ( expr ) .)
    DOTDIV          reduce using rule 45 (term -> EYE ( expr ) .)
    DOTMUL          reduce using rule 45 (term -> EYE ( expr ) .)
    DOTSUB          reduce using rule 45 (term -> EYE ( expr ) .)
    DOTADD          reduce using rule 45 (term -> EYE ( expr ) .)
    /               reduce using rule 45 (term -> EYE ( expr ) .)
    *               reduce using rule 45 (term -> EYE ( expr ) .)
    -               reduce using rule 45 (term -> EYE ( expr ) .)
    +               reduce using rule 45 (term -> EYE ( expr ) .)
    ;               reduce using rule 45 (term -> EYE ( expr ) .)
    ,               reduce using rule 45 (term -> EYE ( expr ) .)
    ]               reduce using rule 45 (term -> EYE ( expr ) .)
    )               reduce using rule 45 (term -> EYE ( expr ) .)
    :               reduce using rule 45 (term -> EYE ( expr ) .)
    RETURN          reduce using rule 45 (term -> EYE ( expr ) .)
    PRINT           reduce using rule 45 (term -> EYE ( expr ) .)
    CONTINUE        reduce using rule 45 (term -> EYE ( expr ) .)
    BREAK           reduce using rule 45 (term -> EYE ( expr ) .)
    FOR             reduce using rule 45 (term -> EYE ( expr ) .)
    WHILE           reduce using rule 45 (term -> EYE ( expr ) .)
    IF              reduce using rule 45 (term -> EYE ( expr ) .)
    {               reduce using rule 45 (term -> EYE ( expr ) .)
    ID              reduce using rule 45 (term -> EYE ( expr ) .)
    STRING          reduce using rule 45 (term -> EYE ( expr ) .)
    FLOATNUM        reduce using rule 45 (term -> EYE ( expr ) .)
    INTNUM          reduce using rule 45 (term -> EYE ( expr ) .)
    EYE             reduce using rule 45 (term -> EYE ( expr ) .)
    ONES            reduce using rule 45 (term -> EYE ( expr ) .)
    ZEROS           reduce using rule 45 (term -> EYE ( expr ) .)


state 106

    (46) term -> ONES ( vector ) .
    DIVASSIGN       reduce using rule 46 (term -> ONES ( vector ) .)
    MULASSIGN       reduce using rule 46 (term -> ONES ( vector ) .)
    SUBASSIGN       reduce using rule 46 (term -> ONES ( vector ) .)
    ADDASSIGN       reduce using rule 46 (term -> ONES ( vector ) .)
    =               reduce using rule 46 (term -> ONES ( vector ) .)
    [               reduce using rule 46 (term -> ONES ( vector ) .)
    NEQ             reduce using rule 46 (term -> ONES ( vector ) .)
    EQU             reduce using rule 46 (term -> ONES ( vector ) .)
    GEQ             reduce using rule 46 (term -> ONES ( vector ) .)
    LEQ             reduce using rule 46 (term -> ONES ( vector ) .)
    >               reduce using rule 46 (term -> ONES ( vector ) .)
    <               reduce using rule 46 (term -> ONES ( vector ) .)
    '               reduce using rule 46 (term -> ONES ( vector ) .)
    DOTDIV          reduce using rule 46 (term -> ONES ( vector ) .)
    DOTMUL          reduce using rule 46 (term -> ONES ( vector ) .)
    DOTSUB          reduce using rule 46 (term -> ONES ( vector ) .)
    DOTADD          reduce using rule 46 (term -> ONES ( vector ) .)
    /               reduce using rule 46 (term -> ONES ( vector ) .)
    *               reduce using rule 46 (term -> ONES ( vector ) .)
    -               reduce using rule 46 (term -> ONES ( vector ) .)
    +               reduce using rule 46 (term -> ONES ( vector ) .)
    ;               reduce using rule 46 (term -> ONES ( vector ) .)
    ,               reduce using rule 46 (term -> ONES ( vector ) .)
    ]               reduce using rule 46 (term -> ONES ( vector ) .)
    )               reduce using rule 46 (term -> ONES ( vector ) .)
    :               reduce using rule 46 (term -> ONES ( vector ) .)
    RETURN          reduce using rule 46 (term -> ONES ( vector ) .)
    PRINT           reduce using rule 46 (term -> ONES ( vector ) .)
    CONTINUE        reduce using rule 46 (term -> ONES ( vector ) .)
    BREAK           reduce using rule 46 (term -> ONES ( vector ) .)
    FOR             reduce using rule 46 (term -> ONES ( vector ) .)
    WHILE           reduce using rule 46 (term -> ONES ( vector ) .)
    IF              reduce using rule 46 (term -> ONES ( vector ) .)
    {               reduce using rule 46 (term -> ONES ( vector ) .)
    ID              reduce using rule 46 (term -> ONES ( vector ) .)
    STRING          reduce using rule 46 (term -> ONES ( vector ) .)
    FLOATNUM        reduce using rule 46 (term -> ONES ( vector ) .)
    INTNUM          reduce using rule 46 (term -> ONES ( vector ) .)
    EYE             reduce using rule 46 (term -> ONES ( vector ) .)
    ONES            reduce using rule 46 (term -> ONES ( vector ) .)
    ZEROS           reduce using rule 46 (term -> ONES ( vector ) .)


state 107

    (47) term -> ZEROS ( vector ) .
    DIVASSIGN       reduce using rule 47 (term -> ZEROS ( vector ) .)
    MULASSIGN       reduce using rule 47 (term -> ZEROS ( vector ) .)
    SUBASSIGN       reduce using rule 47 (term -> ZEROS ( vector ) .)
    ADDASSIGN       reduce using rule 47 (term -> ZEROS ( vector ) .)
    =               reduce using rule 47 (term -> ZEROS ( vector ) .)
    [               reduce using rule 47 (term -> ZEROS ( vector ) .)
    NEQ             reduce using rule 47 (term -> ZEROS ( vector ) .)
    EQU             reduce using rule 47 (term -> ZEROS ( vector ) .)
    GEQ             reduce using rule 47 (term -> ZEROS ( vector ) .)
    LEQ             reduce using rule 47 (term -> ZEROS ( vector ) .)
    >               reduce using rule 47 (term -> ZEROS ( vector ) .)
    <               reduce using rule 47 (term -> ZEROS ( vector ) .)
    '               reduce using rule 47 (term -> ZEROS ( vector ) .)
    DOTDIV          reduce using rule 47 (term -> ZEROS ( vector ) .)
    DOTMUL          reduce using rule 47 (term -> ZEROS ( vector ) .)
    DOTSUB          reduce using rule 47 (term -> ZEROS ( vector ) .)
    DOTADD          reduce using rule 47 (term -> ZEROS ( vector ) .)
    /               reduce using rule 47 (term -> ZEROS ( vector ) .)
    *               reduce using rule 47 (term -> ZEROS ( vector ) .)
    -               reduce using rule 47 (term -> ZEROS ( vector ) .)
    +               reduce using rule 47 (term -> ZEROS ( vector ) .)
    ;               reduce using rule 47 (term -> ZEROS ( vector ) .)
    ,               reduce using rule 47 (term -> ZEROS ( vector ) .)
    ]               reduce using rule 47 (term -> ZEROS ( vector ) .)
    )               reduce using rule 47 (term -> ZEROS ( vector ) .)
    :               reduce using rule 47 (term -> ZEROS ( vector ) .)
    RETURN          reduce using rule 47 (term -> ZEROS ( vector ) .)
    PRINT           reduce using rule 47 (term -> ZEROS ( vector ) .)
    CONTINUE        reduce using rule 47 (term -> ZEROS ( vector ) .)
    BREAK           reduce using rule 47 (term -> ZEROS ( vector ) .)
    FOR             reduce using rule 47 (term -> ZEROS ( vector ) .)
    WHILE           reduce using rule 47 (term -> ZEROS ( vector ) .)
    IF              reduce using rule 47 (term -> ZEROS ( vector ) .)
    {               reduce using rule 47 (term -> ZEROS ( vector ) .)
    ID              reduce using rule 47 (term -> ZEROS ( vector ) .)
    STRING          reduce using rule 47 (term -> ZEROS ( vector ) .)
    FLOATNUM        reduce using rule 47 (term -> ZEROS ( vector ) .)
    INTNUM          reduce using rule 47 (term -> ZEROS ( vector ) .)
    EYE             reduce using rule 47 (term -> ZEROS ( vector ) .)
    ONES            reduce using rule 47 (term -> ZEROS ( vector ) .)
    ZEROS           reduce using rule 47 (term -> ZEROS ( vector ) .)


state 108

    (13) stmt -> FOR term = expr : . expr stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr '
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr DOTDIV expr
    (31) expr -> . expr DOTMUL expr
    (32) expr -> . expr DOTSUB expr
    (33) expr -> . expr DOTADD expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    [               shift and go to state 23
    (               shift and go to state 25
    -               shift and go to state 26
    +               shift and go to state 27
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 24
    expr                           shift and go to state 111

state 109

    (14) stmt -> WHILE ( expr ) stmt .
    RETURN          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    PRINT           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    FLOATNUM        reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    INTNUM          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    EYE             reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ONES            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ZEROS           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    $end            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)


state 110

    (15) stmt -> IF ( expr ) stmt .
    (16) stmt -> IF ( expr ) stmt . ELSE stmt
    RETURN          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    PRINT           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FLOATNUM        reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    INTNUM          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    EYE             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ONES            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ZEROS           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    $end            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    }               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 112


state 111

    (13) stmt -> FOR term = expr : expr . stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . '
    (30) expr -> expr . DOTDIV expr
    (31) expr -> expr . DOTMUL expr
    (32) expr -> expr . DOTSUB expr
    (33) expr -> expr . DOTADD expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    NEQ             shift and go to state 46
    EQU             shift and go to state 47
    GEQ             shift and go to state 48
    LEQ             shift and go to state 49
    >               shift and go to state 50
    <               shift and go to state 51
    '               shift and go to state 52
    DOTDIV          shift and go to state 53
    DOTMUL          shift and go to state 54
    DOTSUB          shift and go to state 55
    DOTADD          shift and go to state 56
    /               shift and go to state 57
    *               shift and go to state 58
    -               shift and go to state 59
    +               shift and go to state 60
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    term                           shift and go to state 8
    stmt                           shift and go to state 113

state 112

    (16) stmt -> IF ( expr ) stmt ELSE . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . term DIVASSIGN expr ;
    (9) stmt -> . term MULASSIGN expr ;
    (10) stmt -> . term SUBASSIGN expr ;
    (11) stmt -> . term ADDASSIGN expr ;
    (12) stmt -> . term = expr ;
    (13) stmt -> . FOR term = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (41) term -> . ID
    (42) term -> . STRING
    (43) term -> . FLOATNUM
    (44) term -> . INTNUM
    (45) term -> . EYE ( expr )
    (46) term -> . ONES ( vector )
    (47) term -> . ZEROS ( vector )
    (48) term -> . term [ vector ]
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    ID              shift and go to state 13
    STRING          shift and go to state 14
    FLOATNUM        shift and go to state 15
    INTNUM          shift and go to state 16
    EYE             shift and go to state 17
    ONES            shift and go to state 18
    ZEROS           shift and go to state 19

    stmt                           shift and go to state 114
    term                           shift and go to state 8

state 113

    (13) stmt -> FOR term = expr : expr stmt .
    RETURN          reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    PRINT           reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    CONTINUE        reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    BREAK           reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    FOR             reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    WHILE           reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    IF              reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    {               reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    ID              reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    STRING          reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    FLOATNUM        reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    INTNUM          reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    EYE             reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    ONES            reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    ZEROS           reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    $end            reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    }               reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)
    ELSE            reduce using rule 13 (stmt -> FOR term = expr : expr stmt .)


state 114

    (16) stmt -> IF ( expr ) stmt ELSE stmt .
    RETURN          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINT           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOATNUM        reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INTNUM          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    EYE             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ONES            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ZEROS           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    $end            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)

Grammar:

Rule 0     S' -> program
Rule 1     program -> stmt_set
Rule 2     stmt_set -> stmt_set stmt
Rule 3     stmt_set -> stmt
Rule 4     stmt -> RETURN vector ;
Rule 5     stmt -> PRINT vector ;
Rule 6     stmt -> CONTINUE ;
Rule 7     stmt -> BREAK ;
Rule 8     stmt -> lvalue DIVASSIGN expr ;
Rule 9     stmt -> lvalue MULASSIGN expr ;
Rule 10    stmt -> lvalue SUBASSIGN expr ;
Rule 11    stmt -> lvalue ADDASSIGN expr ;
Rule 12    stmt -> lvalue = expr ;
Rule 13    stmt -> FOR ID = expr : expr stmt
Rule 14    stmt -> WHILE ( expr ) stmt
Rule 15    stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 16    stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 17    stmt -> { stmt_set }
Rule 18    expr -> [ vector ]
Rule 19    expr -> term
Rule 20    expr -> expr NEQ expr  [precedence=nonassoc, level=4]
Rule 21    expr -> expr EQU expr  [precedence=nonassoc, level=4]
Rule 22    expr -> expr GEQ expr  [precedence=nonassoc, level=5]
Rule 23    expr -> expr LEQ expr  [precedence=nonassoc, level=5]
Rule 24    expr -> expr > expr  [precedence=nonassoc, level=5]
Rule 25    expr -> expr < expr  [precedence=nonassoc, level=5]
Rule 26    expr -> ( expr )
Rule 27    expr -> expr TRANSPOSE  [precedence=left, level=9]
Rule 28    expr -> - expr  [precedence=right, level=8]
Rule 29    expr -> + expr  [precedence=right, level=8]
Rule 30    expr -> expr @ expr  [precedence=left, level=7]
Rule 31    expr -> expr / expr  [precedence=left, level=7]
Rule 32    expr -> expr * expr  [precedence=left, level=7]
Rule 33    expr -> expr - expr  [precedence=left, level=6]
Rule 34    expr -> expr + expr  [precedence=left, level=6]
Rule 35    vector -> <empty>
Rule 36    vector -> expr
Rule 37    vector -> vector , expr
Rule 38    term -> STRING
Rule 39    term -> FLOATNUM
Rule 40    term -> INTNUM
Rule 41    term -> EYE ( expr )
Rule 42    term -> ONES ( vector )
Rule 43    term -> ZEROS ( vector )
Rule 44    term -> lvalue
Rule 45    lvalue -> ID
Rule 46    lvalue -> term [ vector ]

Terminals, with rules where they appear:

(                    : 14 15 16 26 41 42 43
)                    : 14 15 16 26 41 42 43
*                    : 32
+                    : 29 34
,                    : 37
-                    : 28 33
/                    : 31
:                    : 13
;                    : 4 5 6 7 8 9 10 11 12
<                    : 25
=                    : 12 13
>                    : 24
@                    : 30
ADDASSIGN            : 11
BREAK                : 7
CONTINUE             : 6
DIVASSIGN            : 8
ELSE                 : 16
EQU                  : 21
EYE                  : 41
FLOATNUM             : 39
FOR                  : 13
GEQ                  : 22
ID                   : 13 45
IF                   : 15 16
INTNUM               : 40
LEQ                  : 23
MULASSIGN            : 9
NEQ                  : 20
ONES                 : 42
PRINT                : 5
RETURN               : 4
STRING               : 38
SUBASSIGN            : 10
TRANSPOSE            : 27
WHILE                : 14
ZEROS                : 43
[                    : 18 46
]                    : 18 46
error                : 
{                    : 17
}                    : 17

Nonterminals, with rules where they appear:

expr                 : 8 9 10 11 12 13 13 14 15 16 20 20 21 21 22 22 23 23 24 24 25 25 26 27 28 29 30 30 31 31 32 32 33 33 34 34 36 37 41
lvalue               : 8 9 10 11 12 44
program              : 0
stmt                 : 2 3 13 14 15 16 16
stmt_set             : 1 2 17
term                 : 19 46
vector               : 4 5 18 37 42 43 46


state 0

    (0) S' -> . program
    (1) program -> . stmt_set
    (2) stmt_set -> . stmt_set stmt
    (3) stmt_set -> . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    program                        shift and go to state 1
    stmt_set                       shift and go to state 2
    stmt                           shift and go to state 3
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 1

    (0) S' -> program .


state 2

    (1) program -> stmt_set .
    (2) stmt_set -> stmt_set . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    $end            reduce using rule 1 (program -> stmt_set .)
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 21
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 3

    (3) stmt_set -> stmt .
    RETURN          reduce using rule 3 (stmt_set -> stmt .)
    PRINT           reduce using rule 3 (stmt_set -> stmt .)
    CONTINUE        reduce using rule 3 (stmt_set -> stmt .)
    BREAK           reduce using rule 3 (stmt_set -> stmt .)
    FOR             reduce using rule 3 (stmt_set -> stmt .)
    WHILE           reduce using rule 3 (stmt_set -> stmt .)
    IF              reduce using rule 3 (stmt_set -> stmt .)
    {               reduce using rule 3 (stmt_set -> stmt .)
    ID              reduce using rule 3 (stmt_set -> stmt .)
    STRING          reduce using rule 3 (stmt_set -> stmt .)
    FLOATNUM        reduce using rule 3 (stmt_set -> stmt .)
    INTNUM          reduce using rule 3 (stmt_set -> stmt .)
    EYE             reduce using rule 3 (stmt_set -> stmt .)
    ONES            reduce using rule 3 (stmt_set -> stmt .)
    ZEROS           reduce using rule 3 (stmt_set -> stmt .)
    $end            reduce using rule 3 (stmt_set -> stmt .)
    }               reduce using rule 3 (stmt_set -> stmt .)


state 4

    (4) stmt -> RETURN . vector ;
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    ;               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    vector                         shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 5

    (5) stmt -> PRINT . vector ;
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    ;               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    vector                         shift and go to state 30
    expr                           shift and go to state 23
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 6

    (6) stmt -> CONTINUE . ;
    ;               shift and go to state 31


state 7

    (7) stmt -> BREAK . ;
    ;               shift and go to state 32


state 8

    (8) stmt -> lvalue . DIVASSIGN expr ;
    (9) stmt -> lvalue . MULASSIGN expr ;
    (10) stmt -> lvalue . SUBASSIGN expr ;
    (11) stmt -> lvalue . ADDASSIGN expr ;
    (12) stmt -> lvalue . = expr ;
    (44) term -> lvalue .
    DIVASSIGN       shift and go to state 33
    MULASSIGN       shift and go to state 34
    SUBASSIGN       shift and go to state 35
    ADDASSIGN       shift and go to state 36
    =               shift and go to state 37
    [               reduce using rule 44 (term -> lvalue .)


state 9

    (13) stmt -> FOR . ID = expr : expr stmt
    ID              shift and go to state 38


state 10

    (45) lvalue -> ID .
    DIVASSIGN       reduce using rule 45 (lvalue -> ID .)
    MULASSIGN       reduce using rule 45 (lvalue -> ID .)
    SUBASSIGN       reduce using rule 45 (lvalue -> ID .)
    ADDASSIGN       reduce using rule 45 (lvalue -> ID .)
    =               reduce using rule 45 (lvalue -> ID .)
    [               reduce using rule 45 (lvalue -> ID .)
    NEQ             reduce using rule 45 (lvalue -> ID .)
    EQU             reduce using rule 45 (lvalue -> ID .)
    GEQ             reduce using rule 45 (lvalue -> ID .)
    LEQ             reduce using rule 45 (lvalue -> ID .)
    >               reduce using rule 45 (lvalue -> ID .)
    <               reduce using rule 45 (lvalue -> ID .)
    TRANSPOSE       reduce using rule 45 (lvalue -> ID .)
    @               reduce using rule 45 (lvalue -> ID .)
    /               reduce using rule 45 (lvalue -> ID .)
    *               reduce using rule 45 (lvalue -> ID .)
    -               reduce using rule 45 (lvalue -> ID .)
    +               reduce using rule 45 (lvalue -> ID .)
    ;               reduce using rule 45 (lvalue -> ID .)
    ,               reduce using rule 45 (lvalue -> ID .)
    ]               reduce using rule 45 (lvalue -> ID .)
    )               reduce using rule 45 (lvalue -> ID .)
    :               reduce using rule 45 (lvalue -> ID .)
    RETURN          reduce using rule 45 (lvalue -> ID .)
    PRINT           reduce using rule 45 (lvalue -> ID .)
    CONTINUE        reduce using rule 45 (lvalue -> ID .)
    BREAK           reduce using rule 45 (lvalue -> ID .)
    FOR             reduce using rule 45 (lvalue -> ID .)
    WHILE           reduce using rule 45 (lvalue -> ID .)
    IF              reduce using rule 45 (lvalue -> ID .)
    {               reduce using rule 45 (lvalue -> ID .)
    ID              reduce using rule 45 (lvalue -> ID .)
    STRING          reduce using rule 45 (lvalue -> ID .)
    FLOATNUM        reduce using rule 45 (lvalue -> ID .)
    INTNUM          reduce using rule 45 (lvalue -> ID .)
    EYE             reduce using rule 45 (lvalue -> ID .)
    ONES            reduce using rule 45 (lvalue -> ID .)
    ZEROS           reduce using rule 45 (lvalue -> ID .)


state 11

    (14) stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 39


state 12

    (15) stmt -> IF . ( expr ) stmt
    (16) stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 40


state 13

    (17) stmt -> { . stmt_set }
    (2) stmt_set -> . stmt_set stmt
    (3) stmt_set -> . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt_set                       shift and go to state 41
    stmt                           shift and go to state 3
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 14

    (46) lvalue -> term . [ vector ]
    [               shift and go to state 42


state 15

    (38) term -> STRING .
    [               reduce using rule 38 (term -> STRING .)
    NEQ             reduce using rule 38 (term -> STRING .)
    EQU             reduce using rule 38 (term -> STRING .)
    GEQ             reduce using rule 38 (term -> STRING .)
    LEQ             reduce using rule 38 (term -> STRING .)
    >               reduce using rule 38 (term -> STRING .)
    <               reduce using rule 38 (term -> STRING .)
    TRANSPOSE       reduce using rule 38 (term -> STRING .)
    @               reduce using rule 38 (term -> STRING .)
    /               reduce using rule 38 (term -> STRING .)
    *               reduce using rule 38 (term -> STRING .)
    -               reduce using rule 38 (term -> STRING .)
    +               reduce using rule 38 (term -> STRING .)
    ;               reduce using rule 38 (term -> STRING .)
    ,               reduce using rule 38 (term -> STRING .)
    ]               reduce using rule 38 (term -> STRING .)
    )               reduce using rule 38 (term -> STRING .)
    :               reduce using rule 38 (term -> STRING .)
    RETURN          reduce using rule 38 (term -> STRING .)
    PRINT           reduce using rule 38 (term -> STRING .)
    CONTINUE        reduce using rule 38 (term -> STRING .)
    BREAK           reduce using rule 38 (term -> STRING .)
    FOR             reduce using rule 38 (term -> STRING .)
    WHILE           reduce using rule 38 (term -> STRING .)
    IF              reduce using rule 38 (term -> STRING .)
    {               reduce using rule 38 (term -> STRING .)
    ID              reduce using rule 38 (term -> STRING .)
    STRING          reduce using rule 38 (term -> STRING .)
    FLOATNUM        reduce using rule 38 (term -> STRING .)
    INTNUM          reduce using rule 38 (term -> STRING .)
    EYE             reduce using rule 38 (term -> STRING .)
    ONES            reduce using rule 38 (term -> STRING .)
    ZEROS           reduce using rule 38 (term -> STRING .)


state 16

    (39) term -> FLOATNUM .
    [               reduce using rule 39 (term -> FLOATNUM .)
    NEQ             reduce using rule 39 (term -> FLOATNUM .)
    EQU             reduce using rule 39 (term -> FLOATNUM .)
    GEQ             reduce using rule 39 (term -> FLOATNUM .)
    LEQ             reduce using rule 39 (term -> FLOATNUM .)
    >               reduce using rule 39 (term -> FLOATNUM .)
    <               reduce using rule 39 (term -> FLOATNUM .)
    TRANSPOSE       reduce using rule 39 (term -> FLOATNUM .)
    @               reduce using rule 39 (term -> FLOATNUM .)
    /               reduce using rule 39 (term -> FLOATNUM .)
    *               reduce using rule 39 (term -> FLOATNUM .)
    -               reduce using rule 39 (term -> FLOATNUM .)
    +               reduce using rule 39 (term -> FLOATNUM .)
    ;               reduce using rule 39 (term -> FLOATNUM .)
    ,               reduce using rule 39 (term -> FLOATNUM .)
    ]               reduce using rule 39 (term -> FLOATNUM .)
    )               reduce using rule 39 (term -> FLOATNUM .)
    :               reduce using rule 39 (term -> FLOATNUM .)
    RETURN          reduce using rule 39 (term -> FLOATNUM .)
    PRINT           reduce using rule 39 (term -> FLOATNUM .)
    CONTINUE        reduce using rule 39 (term -> FLOATNUM .)
    BREAK           reduce using rule 39 (term -> FLOATNUM .)
    FOR             reduce using rule 39 (term -> FLOATNUM .)
    WHILE           reduce using rule 39 (term -> FLOATNUM .)
    IF              reduce using rule 39 (term -> FLOATNUM .)
    {               reduce using rule 39 (term -> FLOATNUM .)
    ID              reduce using rule 39 (term -> FLOATNUM .)
    STRING          reduce using rule 39 (term -> FLOATNUM .)
    FLOATNUM        reduce using rule 39 (term -> FLOATNUM .)
    INTNUM          reduce using rule 39 (term -> FLOATNUM .)
    EYE             reduce using rule 39 (term -> FLOATNUM .)
    ONES            reduce using rule 39 (term -> FLOATNUM .)
    ZEROS           reduce using rule 39 (term -> FLOATNUM .)


state 17

    (40) term -> INTNUM .
    [               reduce using rule 40 (term -> INTNUM .)
    NEQ             reduce using rule 40 (term -> INTNUM .)
    EQU             reduce using rule 40 (term -> INTNUM .)
    GEQ             reduce using rule 40 (term -> INTNUM .)
    LEQ             reduce using rule 40 (term -> INTNUM .)
    >               reduce using rule 40 (term -> INTNUM .)
    <               reduce using rule 40 (term -> INTNUM .)
    TRANSPOSE       reduce using rule 40 (term -> INTNUM .)
    @               reduce using rule 40 (term -> INTNUM .)
    /               reduce using rule 40 (term -> INTNUM .)
    *               reduce using rule 40 (term -> INTNUM .)
    -               reduce using rule 40 (term -> INTNUM .)
    +               reduce using rule 40 (term -> INTNUM .)
    ;               reduce using rule 40 (term -> INTNUM .)
    ,               reduce using rule 40 (term -> INTNUM .)
    ]               reduce using rule 40 (term -> INTNUM .)
    )               reduce using rule 40 (term -> INTNUM .)
    :               reduce using rule 40 (term -> INTNUM .)
    RETURN          reduce using rule 40 (term -> INTNUM .)
    PRINT           reduce using rule 40 (term -> INTNUM .)
    CONTINUE        reduce using rule 40 (term -> INTNUM .)
    BREAK           reduce using rule 40 (term -> INTNUM .)
    FOR             reduce using rule 40 (term -> INTNUM .)
    WHILE           reduce using rule 40 (term -> INTNUM .)
    IF              reduce using rule 40 (term -> INTNUM .)
    {               reduce using rule 40 (term -> INTNUM .)
    ID              reduce using rule 40 (term -> INTNUM .)
    STRING          reduce using rule 40 (term -> INTNUM .)
    FLOATNUM        reduce using rule 40 (term -> INTNUM .)
    INTNUM          reduce using rule 40 (term -> INTNUM .)
    EYE             reduce using rule 40 (term -> INTNUM .)
    ONES            reduce using rule 40 (term -> INTNUM .)
    ZEROS           reduce using rule 40 (term -> INTNUM .)


state 18

    (41) term -> EYE . ( expr )
    (               shift and go to state 43


state 19

    (42) term -> ONES . ( vector )
    (               shift and go to state 44


state 20

    (43) term -> ZEROS . ( vector )
    (               shift and go to state 45


state 21

    (2) stmt_set -> stmt_set stmt .
    RETURN          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    PRINT           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    CONTINUE        reduce using rule 2 (stmt_set -> stmt_set stmt .)
    BREAK           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    FOR             reduce using rule 2 (stmt_set -> stmt_set stmt .)
    WHILE           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    IF              reduce using rule 2 (stmt_set -> stmt_set stmt .)
    {               reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ID              reduce using rule 2 (stmt_set -> stmt_set stmt .)
    STRING          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    FLOATNUM        reduce using rule 2 (stmt_set -> stmt_set stmt .)
    INTNUM          reduce using rule 2 (stmt_set -> stmt_set stmt .)
    EYE             reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ONES            reduce using rule 2 (stmt_set -> stmt_set stmt .)
    ZEROS           reduce using rule 2 (stmt_set -> stmt_set stmt .)
    $end            reduce using rule 2 (stmt_set -> stmt_set stmt .)
    }               reduce using rule 2 (stmt_set -> stmt_set stmt .)


state 22

    (4) stmt -> RETURN vector . ;
    (37) vector -> vector . , expr
    ;               shift and go to state 46
    ,               shift and go to state 47


state 23

    (36) vector -> expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               reduce using rule 36 (vector -> expr .)
    ,               reduce using rule 36 (vector -> expr .)
    ]               reduce using rule 36 (vector -> expr .)
    )               reduce using rule 36 (vector -> expr .)
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 24

    (18) expr -> [ . vector ]
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    ]               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    vector                         shift and go to state 60
    expr                           shift and go to state 23
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 25

    (19) expr -> term .
    (46) lvalue -> term . [ vector ]
    NEQ             reduce using rule 19 (expr -> term .)
    EQU             reduce using rule 19 (expr -> term .)
    GEQ             reduce using rule 19 (expr -> term .)
    LEQ             reduce using rule 19 (expr -> term .)
    >               reduce using rule 19 (expr -> term .)
    <               reduce using rule 19 (expr -> term .)
    TRANSPOSE       reduce using rule 19 (expr -> term .)
    @               reduce using rule 19 (expr -> term .)
    /               reduce using rule 19 (expr -> term .)
    *               reduce using rule 19 (expr -> term .)
    -               reduce using rule 19 (expr -> term .)
    +               reduce using rule 19 (expr -> term .)
    ;               reduce using rule 19 (expr -> term .)
    ,               reduce using rule 19 (expr -> term .)
    ]               reduce using rule 19 (expr -> term .)
    )               reduce using rule 19 (expr -> term .)
    :               reduce using rule 19 (expr -> term .)
    RETURN          reduce using rule 19 (expr -> term .)
    PRINT           reduce using rule 19 (expr -> term .)
    CONTINUE        reduce using rule 19 (expr -> term .)
    BREAK           reduce using rule 19 (expr -> term .)
    FOR             reduce using rule 19 (expr -> term .)
    WHILE           reduce using rule 19 (expr -> term .)
    IF              reduce using rule 19 (expr -> term .)
    {               reduce using rule 19 (expr -> term .)
    ID              reduce using rule 19 (expr -> term .)
    STRING          reduce using rule 19 (expr -> term .)
    FLOATNUM        reduce using rule 19 (expr -> term .)
    INTNUM          reduce using rule 19 (expr -> term .)
    EYE             reduce using rule 19 (expr -> term .)
    ONES            reduce using rule 19 (expr -> term .)
    ZEROS           reduce using rule 19 (expr -> term .)
    [               shift and go to state 42


state 26

    (26) expr -> ( . expr )
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 61
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 27

    (28) expr -> - . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 62
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 28

    (29) expr -> + . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 63
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 29

    (44) term -> lvalue .
    [               reduce using rule 44 (term -> lvalue .)
    NEQ             reduce using rule 44 (term -> lvalue .)
    EQU             reduce using rule 44 (term -> lvalue .)
    GEQ             reduce using rule 44 (term -> lvalue .)
    LEQ             reduce using rule 44 (term -> lvalue .)
    >               reduce using rule 44 (term -> lvalue .)
    <               reduce using rule 44 (term -> lvalue .)
    TRANSPOSE       reduce using rule 44 (term -> lvalue .)
    @               reduce using rule 44 (term -> lvalue .)
    /               reduce using rule 44 (term -> lvalue .)
    *               reduce using rule 44 (term -> lvalue .)
    -               reduce using rule 44 (term -> lvalue .)
    +               reduce using rule 44 (term -> lvalue .)
    ;               reduce using rule 44 (term -> lvalue .)
    ,               reduce using rule 44 (term -> lvalue .)
    ]               reduce using rule 44 (term -> lvalue .)
    )               reduce using rule 44 (term -> lvalue .)
    :               reduce using rule 44 (term -> lvalue .)
    RETURN          reduce using rule 44 (term -> lvalue .)
    PRINT           reduce using rule 44 (term -> lvalue .)
    CONTINUE        reduce using rule 44 (term -> lvalue .)
    BREAK           reduce using rule 44 (term -> lvalue .)
    FOR             reduce using rule 44 (term -> lvalue .)
    WHILE           reduce using rule 44 (term -> lvalue .)
    IF              reduce using rule 44 (term -> lvalue .)
    {               reduce using rule 44 (term -> lvalue .)
    ID              reduce using rule 44 (term -> lvalue .)
    STRING          reduce using rule 44 (term -> lvalue .)
    FLOATNUM        reduce using rule 44 (term -> lvalue .)
    INTNUM          reduce using rule 44 (term -> lvalue .)
    EYE             reduce using rule 44 (term -> lvalue .)
    ONES            reduce using rule 44 (term -> lvalue .)
    ZEROS           reduce using rule 44 (term -> lvalue .)


state 30

    (5) stmt -> PRINT vector . ;
    (37) vector -> vector . , expr
    ;               shift and go to state 64
    ,               shift and go to state 47


state 31

    (6) stmt -> CONTINUE ; .
    RETURN          reduce using rule 6 (stmt -> CONTINUE ; .)
    PRINT           reduce using rule 6 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 6 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 6 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 6 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 6 (stmt -> CONTINUE ; .)
    IF              reduce using rule 6 (stmt -> CONTINUE ; .)
    {               reduce using rule 6 (stmt -> CONTINUE ; .)
    ID              reduce using rule 6 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 6 (stmt -> CONTINUE ; .)
    FLOATNUM        reduce using rule 6 (stmt -> CONTINUE ; .)
    INTNUM          reduce using rule 6 (stmt -> CONTINUE ; .)
    EYE             reduce using rule 6 (stmt -> CONTINUE ; .)
    ONES            reduce using rule 6 (stmt -> CONTINUE ; .)
    ZEROS           reduce using rule 6 (stmt -> CONTINUE ; .)
    $end            reduce using rule 6 (stmt -> CONTINUE ; .)
    }               reduce using rule 6 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 6 (stmt -> CONTINUE ; .)


state 32

    (7) stmt -> BREAK ; .
    RETURN          reduce using rule 7 (stmt -> BREAK ; .)
    PRINT           reduce using rule 7 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 7 (stmt -> BREAK ; .)
    BREAK           reduce using rule 7 (stmt -> BREAK ; .)
    FOR             reduce using rule 7 (stmt -> BREAK ; .)
    WHILE           reduce using rule 7 (stmt -> BREAK ; .)
    IF              reduce using rule 7 (stmt -> BREAK ; .)
    {               reduce using rule 7 (stmt -> BREAK ; .)
    ID              reduce using rule 7 (stmt -> BREAK ; .)
    STRING          reduce using rule 7 (stmt -> BREAK ; .)
    FLOATNUM        reduce using rule 7 (stmt -> BREAK ; .)
    INTNUM          reduce using rule 7 (stmt -> BREAK ; .)
    EYE             reduce using rule 7 (stmt -> BREAK ; .)
    ONES            reduce using rule 7 (stmt -> BREAK ; .)
    ZEROS           reduce using rule 7 (stmt -> BREAK ; .)
    $end            reduce using rule 7 (stmt -> BREAK ; .)
    }               reduce using rule 7 (stmt -> BREAK ; .)
    ELSE            reduce using rule 7 (stmt -> BREAK ; .)


state 33

    (8) stmt -> lvalue DIVASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    lvalue                         shift and go to state 29
    expr                           shift and go to state 65
    term                           shift and go to state 25

state 34

    (9) stmt -> lvalue MULASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    lvalue                         shift and go to state 29
    expr                           shift and go to state 66
    term                           shift and go to state 25

state 35

    (10) stmt -> lvalue SUBASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    lvalue                         shift and go to state 29
    expr                           shift and go to state 67
    term                           shift and go to state 25

state 36

    (11) stmt -> lvalue ADDASSIGN . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    lvalue                         shift and go to state 29
    expr                           shift and go to state 68
    term                           shift and go to state 25

state 37

    (12) stmt -> lvalue = . expr ;
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    lvalue                         shift and go to state 29
    expr                           shift and go to state 69
    term                           shift and go to state 25

state 38

    (13) stmt -> FOR ID . = expr : expr stmt
    =               shift and go to state 70


state 39

    (14) stmt -> WHILE ( . expr ) stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 71
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 40

    (15) stmt -> IF ( . expr ) stmt
    (16) stmt -> IF ( . expr ) stmt ELSE stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 72
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 41

    (17) stmt -> { stmt_set . }
    (2) stmt_set -> stmt_set . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    }               shift and go to state 73
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 21
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 42

    (46) lvalue -> term [ . vector ]
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    ]               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    term                           shift and go to state 25
    vector                         shift and go to state 74
    expr                           shift and go to state 23
    lvalue                         shift and go to state 29

state 43

    (41) term -> EYE ( . expr )
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 75
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 44

    (42) term -> ONES ( . vector )
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    )               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    vector                         shift and go to state 76
    expr                           shift and go to state 23
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 45

    (43) term -> ZEROS ( . vector )
    (35) vector -> .
    (36) vector -> . expr
    (37) vector -> . vector , expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    )               reduce using rule 35 (vector -> .)
    ,               reduce using rule 35 (vector -> .)
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    vector                         shift and go to state 77
    expr                           shift and go to state 23
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 46

    (4) stmt -> RETURN vector ; .
    RETURN          reduce using rule 4 (stmt -> RETURN vector ; .)
    PRINT           reduce using rule 4 (stmt -> RETURN vector ; .)
    CONTINUE        reduce using rule 4 (stmt -> RETURN vector ; .)
    BREAK           reduce using rule 4 (stmt -> RETURN vector ; .)
    FOR             reduce using rule 4 (stmt -> RETURN vector ; .)
    WHILE           reduce using rule 4 (stmt -> RETURN vector ; .)
    IF              reduce using rule 4 (stmt -> RETURN vector ; .)
    {               reduce using rule 4 (stmt -> RETURN vector ; .)
    ID              reduce using rule 4 (stmt -> RETURN vector ; .)
    STRING          reduce using rule 4 (stmt -> RETURN vector ; .)
    FLOATNUM        reduce using rule 4 (stmt -> RETURN vector ; .)
    INTNUM          reduce using rule 4 (stmt -> RETURN vector ; .)
    EYE             reduce using rule 4 (stmt -> RETURN vector ; .)
    ONES            reduce using rule 4 (stmt -> RETURN vector ; .)
    ZEROS           reduce using rule 4 (stmt -> RETURN vector ; .)
    $end            reduce using rule 4 (stmt -> RETURN vector ; .)
    }               reduce using rule 4 (stmt -> RETURN vector ; .)
    ELSE            reduce using rule 4 (stmt -> RETURN vector ; .)


state 47

    (37) vector -> vector , . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 78
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 48

    (20) expr -> expr NEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 79
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 49

    (21) expr -> expr EQU . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 80
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 50

    (22) expr -> expr GEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 81
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 51

    (23) expr -> expr LEQ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 82
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 52

    (24) expr -> expr > . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 83
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 53

    (25) expr -> expr < . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 84
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 54

    (27) expr -> expr TRANSPOSE .
    NEQ             reduce using rule 27 (expr -> expr TRANSPOSE .)
    EQU             reduce using rule 27 (expr -> expr TRANSPOSE .)
    GEQ             reduce using rule 27 (expr -> expr TRANSPOSE .)
    LEQ             reduce using rule 27 (expr -> expr TRANSPOSE .)
    >               reduce using rule 27 (expr -> expr TRANSPOSE .)
    <               reduce using rule 27 (expr -> expr TRANSPOSE .)
    TRANSPOSE       reduce using rule 27 (expr -> expr TRANSPOSE .)
    @               reduce using rule 27 (expr -> expr TRANSPOSE .)
    /               reduce using rule 27 (expr -> expr TRANSPOSE .)
    *               reduce using rule 27 (expr -> expr TRANSPOSE .)
    -               reduce using rule 27 (expr -> expr TRANSPOSE .)
    +               reduce using rule 27 (expr -> expr TRANSPOSE .)
    ;               reduce using rule 27 (expr -> expr TRANSPOSE .)
    ,               reduce using rule 27 (expr -> expr TRANSPOSE .)
    ]               reduce using rule 27 (expr -> expr TRANSPOSE .)
    )               reduce using rule 27 (expr -> expr TRANSPOSE .)
    :               reduce using rule 27 (expr -> expr TRANSPOSE .)
    RETURN          reduce using rule 27 (expr -> expr TRANSPOSE .)
    PRINT           reduce using rule 27 (expr -> expr TRANSPOSE .)
    CONTINUE        reduce using rule 27 (expr -> expr TRANSPOSE .)
    BREAK           reduce using rule 27 (expr -> expr TRANSPOSE .)
    FOR             reduce using rule 27 (expr -> expr TRANSPOSE .)
    WHILE           reduce using rule 27 (expr -> expr TRANSPOSE .)
    IF              reduce using rule 27 (expr -> expr TRANSPOSE .)
    {               reduce using rule 27 (expr -> expr TRANSPOSE .)
    ID              reduce using rule 27 (expr -> expr TRANSPOSE .)
    STRING          reduce using rule 27 (expr -> expr TRANSPOSE .)
    FLOATNUM        reduce using rule 27 (expr -> expr TRANSPOSE .)
    INTNUM          reduce using rule 27 (expr -> expr TRANSPOSE .)
    EYE             reduce using rule 27 (expr -> expr TRANSPOSE .)
    ONES            reduce using rule 27 (expr -> expr TRANSPOSE .)
    ZEROS           reduce using rule 27 (expr -> expr TRANSPOSE .)


state 55

    (30) expr -> expr @ . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 85
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 56

    (31) expr -> expr / . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 86
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 57

    (32) expr -> expr * . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 87
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 58

    (33) expr -> expr - . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 88
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 59

    (34) expr -> expr + . expr
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 89
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 60

    (18) expr -> [ vector . ]
    (37) vector -> vector . , expr
    ]               shift and go to state 90
    ,               shift and go to state 47


state 61

    (26) expr -> ( expr . )
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    )               shift and go to state 91
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 62

    (28) expr -> - expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 28 (expr -> - expr .)
    EQU             reduce using rule 28 (expr -> - expr .)
    GEQ             reduce using rule 28 (expr -> - expr .)
    LEQ             reduce using rule 28 (expr -> - expr .)
    >               reduce using rule 28 (expr -> - expr .)
    <               reduce using rule 28 (expr -> - expr .)
    @               reduce using rule 28 (expr -> - expr .)
    /               reduce using rule 28 (expr -> - expr .)
    *               reduce using rule 28 (expr -> - expr .)
    -               reduce using rule 28 (expr -> - expr .)
    +               reduce using rule 28 (expr -> - expr .)
    ;               reduce using rule 28 (expr -> - expr .)
    ,               reduce using rule 28 (expr -> - expr .)
    ]               reduce using rule 28 (expr -> - expr .)
    )               reduce using rule 28 (expr -> - expr .)
    :               reduce using rule 28 (expr -> - expr .)
    RETURN          reduce using rule 28 (expr -> - expr .)
    PRINT           reduce using rule 28 (expr -> - expr .)
    CONTINUE        reduce using rule 28 (expr -> - expr .)
    BREAK           reduce using rule 28 (expr -> - expr .)
    FOR             reduce using rule 28 (expr -> - expr .)
    WHILE           reduce using rule 28 (expr -> - expr .)
    IF              reduce using rule 28 (expr -> - expr .)
    {               reduce using rule 28 (expr -> - expr .)
    ID              reduce using rule 28 (expr -> - expr .)
    STRING          reduce using rule 28 (expr -> - expr .)
    FLOATNUM        reduce using rule 28 (expr -> - expr .)
    INTNUM          reduce using rule 28 (expr -> - expr .)
    EYE             reduce using rule 28 (expr -> - expr .)
    ONES            reduce using rule 28 (expr -> - expr .)
    ZEROS           reduce using rule 28 (expr -> - expr .)
    TRANSPOSE       shift and go to state 54


state 63

    (29) expr -> + expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 29 (expr -> + expr .)
    EQU             reduce using rule 29 (expr -> + expr .)
    GEQ             reduce using rule 29 (expr -> + expr .)
    LEQ             reduce using rule 29 (expr -> + expr .)
    >               reduce using rule 29 (expr -> + expr .)
    <               reduce using rule 29 (expr -> + expr .)
    @               reduce using rule 29 (expr -> + expr .)
    /               reduce using rule 29 (expr -> + expr .)
    *               reduce using rule 29 (expr -> + expr .)
    -               reduce using rule 29 (expr -> + expr .)
    +               reduce using rule 29 (expr -> + expr .)
    ;               reduce using rule 29 (expr -> + expr .)
    ,               reduce using rule 29 (expr -> + expr .)
    ]               reduce using rule 29 (expr -> + expr .)
    )               reduce using rule 29 (expr -> + expr .)
    :               reduce using rule 29 (expr -> + expr .)
    RETURN          reduce using rule 29 (expr -> + expr .)
    PRINT           reduce using rule 29 (expr -> + expr .)
    CONTINUE        reduce using rule 29 (expr -> + expr .)
    BREAK           reduce using rule 29 (expr -> + expr .)
    FOR             reduce using rule 29 (expr -> + expr .)
    WHILE           reduce using rule 29 (expr -> + expr .)
    IF              reduce using rule 29 (expr -> + expr .)
    {               reduce using rule 29 (expr -> + expr .)
    ID              reduce using rule 29 (expr -> + expr .)
    STRING          reduce using rule 29 (expr -> + expr .)
    FLOATNUM        reduce using rule 29 (expr -> + expr .)
    INTNUM          reduce using rule 29 (expr -> + expr .)
    EYE             reduce using rule 29 (expr -> + expr .)
    ONES            reduce using rule 29 (expr -> + expr .)
    ZEROS           reduce using rule 29 (expr -> + expr .)
    TRANSPOSE       shift and go to state 54


state 64

    (5) stmt -> PRINT vector ; .
    RETURN          reduce using rule 5 (stmt -> PRINT vector ; .)
    PRINT           reduce using rule 5 (stmt -> PRINT vector ; .)
    CONTINUE        reduce using rule 5 (stmt -> PRINT vector ; .)
    BREAK           reduce using rule 5 (stmt -> PRINT vector ; .)
    FOR             reduce using rule 5 (stmt -> PRINT vector ; .)
    WHILE           reduce using rule 5 (stmt -> PRINT vector ; .)
    IF              reduce using rule 5 (stmt -> PRINT vector ; .)
    {               reduce using rule 5 (stmt -> PRINT vector ; .)
    ID              reduce using rule 5 (stmt -> PRINT vector ; .)
    STRING          reduce using rule 5 (stmt -> PRINT vector ; .)
    FLOATNUM        reduce using rule 5 (stmt -> PRINT vector ; .)
    INTNUM          reduce using rule 5 (stmt -> PRINT vector ; .)
    EYE             reduce using rule 5 (stmt -> PRINT vector ; .)
    ONES            reduce using rule 5 (stmt -> PRINT vector ; .)
    ZEROS           reduce using rule 5 (stmt -> PRINT vector ; .)
    $end            reduce using rule 5 (stmt -> PRINT vector ; .)
    }               reduce using rule 5 (stmt -> PRINT vector ; .)
    ELSE            reduce using rule 5 (stmt -> PRINT vector ; .)


state 65

    (8) stmt -> lvalue DIVASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               shift and go to state 92
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 66

    (9) stmt -> lvalue MULASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               shift and go to state 93
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 67

    (10) stmt -> lvalue SUBASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               shift and go to state 94
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 68

    (11) stmt -> lvalue ADDASSIGN expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               shift and go to state 95
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 69

    (12) stmt -> lvalue = expr . ;
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               shift and go to state 96
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 70

    (13) stmt -> FOR ID = . expr : expr stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 97
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 71

    (14) stmt -> WHILE ( expr . ) stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    )               shift and go to state 98
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 72

    (15) stmt -> IF ( expr . ) stmt
    (16) stmt -> IF ( expr . ) stmt ELSE stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    )               shift and go to state 99
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 73

    (17) stmt -> { stmt_set } .
    RETURN          reduce using rule 17 (stmt -> { stmt_set } .)
    PRINT           reduce using rule 17 (stmt -> { stmt_set } .)
    CONTINUE        reduce using rule 17 (stmt -> { stmt_set } .)
    BREAK           reduce using rule 17 (stmt -> { stmt_set } .)
    FOR             reduce using rule 17 (stmt -> { stmt_set } .)
    WHILE           reduce using rule 17 (stmt -> { stmt_set } .)
    IF              reduce using rule 17 (stmt -> { stmt_set } .)
    {               reduce using rule 17 (stmt -> { stmt_set } .)
    ID              reduce using rule 17 (stmt -> { stmt_set } .)
    STRING          reduce using rule 17 (stmt -> { stmt_set } .)
    FLOATNUM        reduce using rule 17 (stmt -> { stmt_set } .)
    INTNUM          reduce using rule 17 (stmt -> { stmt_set } .)
    EYE             reduce using rule 17 (stmt -> { stmt_set } .)
    ONES            reduce using rule 17 (stmt -> { stmt_set } .)
    ZEROS           reduce using rule 17 (stmt -> { stmt_set } .)
    $end            reduce using rule 17 (stmt -> { stmt_set } .)
    }               reduce using rule 17 (stmt -> { stmt_set } .)
    ELSE            reduce using rule 17 (stmt -> { stmt_set } .)


state 74

    (46) lvalue -> term [ vector . ]
    (37) vector -> vector . , expr
    ]               shift and go to state 100
    ,               shift and go to state 47


state 75

    (41) term -> EYE ( expr . )
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    )               shift and go to state 101
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 76

    (42) term -> ONES ( vector . )
    (37) vector -> vector . , expr
    )               shift and go to state 102
    ,               shift and go to state 47


state 77

    (43) term -> ZEROS ( vector . )
    (37) vector -> vector . , expr
    )               shift and go to state 103
    ,               shift and go to state 47


state 78

    (37) vector -> vector , expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    ;               reduce using rule 37 (vector -> vector , expr .)
    ,               reduce using rule 37 (vector -> vector , expr .)
    ]               reduce using rule 37 (vector -> vector , expr .)
    )               reduce using rule 37 (vector -> vector , expr .)
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 79

    (20) expr -> expr NEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 20 (expr -> expr NEQ expr .)
    EQU             reduce using rule 20 (expr -> expr NEQ expr .)
    ;               reduce using rule 20 (expr -> expr NEQ expr .)
    ,               reduce using rule 20 (expr -> expr NEQ expr .)
    ]               reduce using rule 20 (expr -> expr NEQ expr .)
    )               reduce using rule 20 (expr -> expr NEQ expr .)
    :               reduce using rule 20 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 20 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 20 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 20 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 20 (expr -> expr NEQ expr .)
    FOR             reduce using rule 20 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 20 (expr -> expr NEQ expr .)
    IF              reduce using rule 20 (expr -> expr NEQ expr .)
    {               reduce using rule 20 (expr -> expr NEQ expr .)
    ID              reduce using rule 20 (expr -> expr NEQ expr .)
    STRING          reduce using rule 20 (expr -> expr NEQ expr .)
    FLOATNUM        reduce using rule 20 (expr -> expr NEQ expr .)
    INTNUM          reduce using rule 20 (expr -> expr NEQ expr .)
    EYE             reduce using rule 20 (expr -> expr NEQ expr .)
    ONES            reduce using rule 20 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 20 (expr -> expr NEQ expr .)
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 80

    (21) expr -> expr EQU expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 21 (expr -> expr EQU expr .)
    EQU             reduce using rule 21 (expr -> expr EQU expr .)
    ;               reduce using rule 21 (expr -> expr EQU expr .)
    ,               reduce using rule 21 (expr -> expr EQU expr .)
    ]               reduce using rule 21 (expr -> expr EQU expr .)
    )               reduce using rule 21 (expr -> expr EQU expr .)
    :               reduce using rule 21 (expr -> expr EQU expr .)
    RETURN          reduce using rule 21 (expr -> expr EQU expr .)
    PRINT           reduce using rule 21 (expr -> expr EQU expr .)
    CONTINUE        reduce using rule 21 (expr -> expr EQU expr .)
    BREAK           reduce using rule 21 (expr -> expr EQU expr .)
    FOR             reduce using rule 21 (expr -> expr EQU expr .)
    WHILE           reduce using rule 21 (expr -> expr EQU expr .)
    IF              reduce using rule 21 (expr -> expr EQU expr .)
    {               reduce using rule 21 (expr -> expr EQU expr .)
    ID              reduce using rule 21 (expr -> expr EQU expr .)
    STRING          reduce using rule 21 (expr -> expr EQU expr .)
    FLOATNUM        reduce using rule 21 (expr -> expr EQU expr .)
    INTNUM          reduce using rule 21 (expr -> expr EQU expr .)
    EYE             reduce using rule 21 (expr -> expr EQU expr .)
    ONES            reduce using rule 21 (expr -> expr EQU expr .)
    ZEROS           reduce using rule 21 (expr -> expr EQU expr .)
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 81

    (22) expr -> expr GEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    EQU             reduce using rule 22 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 22 (expr -> expr GEQ expr .)
    >               reduce using rule 22 (expr -> expr GEQ expr .)
    <               reduce using rule 22 (expr -> expr GEQ expr .)
    ;               reduce using rule 22 (expr -> expr GEQ expr .)
    ,               reduce using rule 22 (expr -> expr GEQ expr .)
    ]               reduce using rule 22 (expr -> expr GEQ expr .)
    )               reduce using rule 22 (expr -> expr GEQ expr .)
    :               reduce using rule 22 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 22 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 22 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 22 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 22 (expr -> expr GEQ expr .)
    FOR             reduce using rule 22 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 22 (expr -> expr GEQ expr .)
    IF              reduce using rule 22 (expr -> expr GEQ expr .)
    {               reduce using rule 22 (expr -> expr GEQ expr .)
    ID              reduce using rule 22 (expr -> expr GEQ expr .)
    STRING          reduce using rule 22 (expr -> expr GEQ expr .)
    FLOATNUM        reduce using rule 22 (expr -> expr GEQ expr .)
    INTNUM          reduce using rule 22 (expr -> expr GEQ expr .)
    EYE             reduce using rule 22 (expr -> expr GEQ expr .)
    ONES            reduce using rule 22 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 22 (expr -> expr GEQ expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 82

    (23) expr -> expr LEQ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    EQU             reduce using rule 23 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 23 (expr -> expr LEQ expr .)
    >               reduce using rule 23 (expr -> expr LEQ expr .)
    <               reduce using rule 23 (expr -> expr LEQ expr .)
    ;               reduce using rule 23 (expr -> expr LEQ expr .)
    ,               reduce using rule 23 (expr -> expr LEQ expr .)
    ]               reduce using rule 23 (expr -> expr LEQ expr .)
    )               reduce using rule 23 (expr -> expr LEQ expr .)
    :               reduce using rule 23 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 23 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 23 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 23 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 23 (expr -> expr LEQ expr .)
    FOR             reduce using rule 23 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 23 (expr -> expr LEQ expr .)
    IF              reduce using rule 23 (expr -> expr LEQ expr .)
    {               reduce using rule 23 (expr -> expr LEQ expr .)
    ID              reduce using rule 23 (expr -> expr LEQ expr .)
    STRING          reduce using rule 23 (expr -> expr LEQ expr .)
    FLOATNUM        reduce using rule 23 (expr -> expr LEQ expr .)
    INTNUM          reduce using rule 23 (expr -> expr LEQ expr .)
    EYE             reduce using rule 23 (expr -> expr LEQ expr .)
    ONES            reduce using rule 23 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 23 (expr -> expr LEQ expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 83

    (24) expr -> expr > expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 24 (expr -> expr > expr .)
    EQU             reduce using rule 24 (expr -> expr > expr .)
    GEQ             reduce using rule 24 (expr -> expr > expr .)
    LEQ             reduce using rule 24 (expr -> expr > expr .)
    >               reduce using rule 24 (expr -> expr > expr .)
    <               reduce using rule 24 (expr -> expr > expr .)
    ;               reduce using rule 24 (expr -> expr > expr .)
    ,               reduce using rule 24 (expr -> expr > expr .)
    ]               reduce using rule 24 (expr -> expr > expr .)
    )               reduce using rule 24 (expr -> expr > expr .)
    :               reduce using rule 24 (expr -> expr > expr .)
    RETURN          reduce using rule 24 (expr -> expr > expr .)
    PRINT           reduce using rule 24 (expr -> expr > expr .)
    CONTINUE        reduce using rule 24 (expr -> expr > expr .)
    BREAK           reduce using rule 24 (expr -> expr > expr .)
    FOR             reduce using rule 24 (expr -> expr > expr .)
    WHILE           reduce using rule 24 (expr -> expr > expr .)
    IF              reduce using rule 24 (expr -> expr > expr .)
    {               reduce using rule 24 (expr -> expr > expr .)
    ID              reduce using rule 24 (expr -> expr > expr .)
    STRING          reduce using rule 24 (expr -> expr > expr .)
    FLOATNUM        reduce using rule 24 (expr -> expr > expr .)
    INTNUM          reduce using rule 24 (expr -> expr > expr .)
    EYE             reduce using rule 24 (expr -> expr > expr .)
    ONES            reduce using rule 24 (expr -> expr > expr .)
    ZEROS           reduce using rule 24 (expr -> expr > expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 84

    (25) expr -> expr < expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 25 (expr -> expr < expr .)
    EQU             reduce using rule 25 (expr -> expr < expr .)
    GEQ             reduce using rule 25 (expr -> expr < expr .)
    LEQ             reduce using rule 25 (expr -> expr < expr .)
    >               reduce using rule 25 (expr -> expr < expr .)
    <               reduce using rule 25 (expr -> expr < expr .)
    ;               reduce using rule 25 (expr -> expr < expr .)
    ,               reduce using rule 25 (expr -> expr < expr .)
    ]               reduce using rule 25 (expr -> expr < expr .)
    )               reduce using rule 25 (expr -> expr < expr .)
    :               reduce using rule 25 (expr -> expr < expr .)
    RETURN          reduce using rule 25 (expr -> expr < expr .)
    PRINT           reduce using rule 25 (expr -> expr < expr .)
    CONTINUE        reduce using rule 25 (expr -> expr < expr .)
    BREAK           reduce using rule 25 (expr -> expr < expr .)
    FOR             reduce using rule 25 (expr -> expr < expr .)
    WHILE           reduce using rule 25 (expr -> expr < expr .)
    IF              reduce using rule 25 (expr -> expr < expr .)
    {               reduce using rule 25 (expr -> expr < expr .)
    ID              reduce using rule 25 (expr -> expr < expr .)
    STRING          reduce using rule 25 (expr -> expr < expr .)
    FLOATNUM        reduce using rule 25 (expr -> expr < expr .)
    INTNUM          reduce using rule 25 (expr -> expr < expr .)
    EYE             reduce using rule 25 (expr -> expr < expr .)
    ONES            reduce using rule 25 (expr -> expr < expr .)
    ZEROS           reduce using rule 25 (expr -> expr < expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 85

    (30) expr -> expr @ expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 30 (expr -> expr @ expr .)
    EQU             reduce using rule 30 (expr -> expr @ expr .)
    GEQ             reduce using rule 30 (expr -> expr @ expr .)
    LEQ             reduce using rule 30 (expr -> expr @ expr .)
    >               reduce using rule 30 (expr -> expr @ expr .)
    <               reduce using rule 30 (expr -> expr @ expr .)
    @               reduce using rule 30 (expr -> expr @ expr .)
    /               reduce using rule 30 (expr -> expr @ expr .)
    *               reduce using rule 30 (expr -> expr @ expr .)
    -               reduce using rule 30 (expr -> expr @ expr .)
    +               reduce using rule 30 (expr -> expr @ expr .)
    ;               reduce using rule 30 (expr -> expr @ expr .)
    ,               reduce using rule 30 (expr -> expr @ expr .)
    ]               reduce using rule 30 (expr -> expr @ expr .)
    )               reduce using rule 30 (expr -> expr @ expr .)
    :               reduce using rule 30 (expr -> expr @ expr .)
    RETURN          reduce using rule 30 (expr -> expr @ expr .)
    PRINT           reduce using rule 30 (expr -> expr @ expr .)
    CONTINUE        reduce using rule 30 (expr -> expr @ expr .)
    BREAK           reduce using rule 30 (expr -> expr @ expr .)
    FOR             reduce using rule 30 (expr -> expr @ expr .)
    WHILE           reduce using rule 30 (expr -> expr @ expr .)
    IF              reduce using rule 30 (expr -> expr @ expr .)
    {               reduce using rule 30 (expr -> expr @ expr .)
    ID              reduce using rule 30 (expr -> expr @ expr .)
    STRING          reduce using rule 30 (expr -> expr @ expr .)
    FLOATNUM        reduce using rule 30 (expr -> expr @ expr .)
    INTNUM          reduce using rule 30 (expr -> expr @ expr .)
    EYE             reduce using rule 30 (expr -> expr @ expr .)
    ONES            reduce using rule 30 (expr -> expr @ expr .)
    ZEROS           reduce using rule 30 (expr -> expr @ expr .)
    TRANSPOSE       shift and go to state 54


state 86

    (31) expr -> expr / expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 31 (expr -> expr / expr .)
    EQU             reduce using rule 31 (expr -> expr / expr .)
    GEQ             reduce using rule 31 (expr -> expr / expr .)
    LEQ             reduce using rule 31 (expr -> expr / expr .)
    >               reduce using rule 31 (expr -> expr / expr .)
    <               reduce using rule 31 (expr -> expr / expr .)
    @               reduce using rule 31 (expr -> expr / expr .)
    /               reduce using rule 31 (expr -> expr / expr .)
    *               reduce using rule 31 (expr -> expr / expr .)
    -               reduce using rule 31 (expr -> expr / expr .)
    +               reduce using rule 31 (expr -> expr / expr .)
    ;               reduce using rule 31 (expr -> expr / expr .)
    ,               reduce using rule 31 (expr -> expr / expr .)
    ]               reduce using rule 31 (expr -> expr / expr .)
    )               reduce using rule 31 (expr -> expr / expr .)
    :               reduce using rule 31 (expr -> expr / expr .)
    RETURN          reduce using rule 31 (expr -> expr / expr .)
    PRINT           reduce using rule 31 (expr -> expr / expr .)
    CONTINUE        reduce using rule 31 (expr -> expr / expr .)
    BREAK           reduce using rule 31 (expr -> expr / expr .)
    FOR             reduce using rule 31 (expr -> expr / expr .)
    WHILE           reduce using rule 31 (expr -> expr / expr .)
    IF              reduce using rule 31 (expr -> expr / expr .)
    {               reduce using rule 31 (expr -> expr / expr .)
    ID              reduce using rule 31 (expr -> expr / expr .)
    STRING          reduce using rule 31 (expr -> expr / expr .)
    FLOATNUM        reduce using rule 31 (expr -> expr / expr .)
    INTNUM          reduce using rule 31 (expr -> expr / expr .)
    EYE             reduce using rule 31 (expr -> expr / expr .)
    ONES            reduce using rule 31 (expr -> expr / expr .)
    ZEROS           reduce using rule 31 (expr -> expr / expr .)
    TRANSPOSE       shift and go to state 54


state 87

    (32) expr -> expr * expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 32 (expr -> expr * expr .)
    EQU             reduce using rule 32 (expr -> expr * expr .)
    GEQ             reduce using rule 32 (expr -> expr * expr .)
    LEQ             reduce using rule 32 (expr -> expr * expr .)
    >               reduce using rule 32 (expr -> expr * expr .)
    <               reduce using rule 32 (expr -> expr * expr .)
    @               reduce using rule 32 (expr -> expr * expr .)
    /               reduce using rule 32 (expr -> expr * expr .)
    *               reduce using rule 32 (expr -> expr * expr .)
    -               reduce using rule 32 (expr -> expr * expr .)
    +               reduce using rule 32 (expr -> expr * expr .)
    ;               reduce using rule 32 (expr -> expr * expr .)
    ,               reduce using rule 32 (expr -> expr * expr .)
    ]               reduce using rule 32 (expr -> expr * expr .)
    )               reduce using rule 32 (expr -> expr * expr .)
    :               reduce using rule 32 (expr -> expr * expr .)
    RETURN          reduce using rule 32 (expr -> expr * expr .)
    PRINT           reduce using rule 32 (expr -> expr * expr .)
    CONTINUE        reduce using rule 32 (expr -> expr * expr .)
    BREAK           reduce using rule 32 (expr -> expr * expr .)
    FOR             reduce using rule 32 (expr -> expr * expr .)
    WHILE           reduce using rule 32 (expr -> expr * expr .)
    IF              reduce using rule 32 (expr -> expr * expr .)
    {               reduce using rule 32 (expr -> expr * expr .)
    ID              reduce using rule 32 (expr -> expr * expr .)
    STRING          reduce using rule 32 (expr -> expr * expr .)
    FLOATNUM        reduce using rule 32 (expr -> expr * expr .)
    INTNUM          reduce using rule 32 (expr -> expr * expr .)
    EYE             reduce using rule 32 (expr -> expr * expr .)
    ONES            reduce using rule 32 (expr -> expr * expr .)
    ZEROS           reduce using rule 32 (expr -> expr * expr .)
    TRANSPOSE       shift and go to state 54


state 88

    (33) expr -> expr - expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 33 (expr -> expr - expr .)
    EQU             reduce using rule 33 (expr -> expr - expr .)
    GEQ             reduce using rule 33 (expr -> expr - expr .)
    LEQ             reduce using rule 33 (expr -> expr - expr .)
    >               reduce using rule 33 (expr -> expr - expr .)
    <               reduce using rule 33 (expr -> expr - expr .)
    -               reduce using rule 33 (expr -> expr - expr .)
    +               reduce using rule 33 (expr -> expr - expr .)
    ;               reduce using rule 33 (expr -> expr - expr .)
    ,               reduce using rule 33 (expr -> expr - expr .)
    ]               reduce using rule 33 (expr -> expr - expr .)
    )               reduce using rule 33 (expr -> expr - expr .)
    :               reduce using rule 33 (expr -> expr - expr .)
    RETURN          reduce using rule 33 (expr -> expr - expr .)
    PRINT           reduce using rule 33 (expr -> expr - expr .)
    CONTINUE        reduce using rule 33 (expr -> expr - expr .)
    BREAK           reduce using rule 33 (expr -> expr - expr .)
    FOR             reduce using rule 33 (expr -> expr - expr .)
    WHILE           reduce using rule 33 (expr -> expr - expr .)
    IF              reduce using rule 33 (expr -> expr - expr .)
    {               reduce using rule 33 (expr -> expr - expr .)
    ID              reduce using rule 33 (expr -> expr - expr .)
    STRING          reduce using rule 33 (expr -> expr - expr .)
    FLOATNUM        reduce using rule 33 (expr -> expr - expr .)
    INTNUM          reduce using rule 33 (expr -> expr - expr .)
    EYE             reduce using rule 33 (expr -> expr - expr .)
    ONES            reduce using rule 33 (expr -> expr - expr .)
    ZEROS           reduce using rule 33 (expr -> expr - expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 89

    (34) expr -> expr + expr .
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    NEQ             reduce using rule 34 (expr -> expr + expr .)
    EQU             reduce using rule 34 (expr -> expr + expr .)
    GEQ             reduce using rule 34 (expr -> expr + expr .)
    LEQ             reduce using rule 34 (expr -> expr + expr .)
    >               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    ,               reduce using rule 34 (expr -> expr + expr .)
    ]               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    :               reduce using rule 34 (expr -> expr + expr .)
    RETURN          reduce using rule 34 (expr -> expr + expr .)
    PRINT           reduce using rule 34 (expr -> expr + expr .)
    CONTINUE        reduce using rule 34 (expr -> expr + expr .)
    BREAK           reduce using rule 34 (expr -> expr + expr .)
    FOR             reduce using rule 34 (expr -> expr + expr .)
    WHILE           reduce using rule 34 (expr -> expr + expr .)
    IF              reduce using rule 34 (expr -> expr + expr .)
    {               reduce using rule 34 (expr -> expr + expr .)
    ID              reduce using rule 34 (expr -> expr + expr .)
    STRING          reduce using rule 34 (expr -> expr + expr .)
    FLOATNUM        reduce using rule 34 (expr -> expr + expr .)
    INTNUM          reduce using rule 34 (expr -> expr + expr .)
    EYE             reduce using rule 34 (expr -> expr + expr .)
    ONES            reduce using rule 34 (expr -> expr + expr .)
    ZEROS           reduce using rule 34 (expr -> expr + expr .)
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 90

    (18) expr -> [ vector ] .
    NEQ             reduce using rule 18 (expr -> [ vector ] .)
    EQU             reduce using rule 18 (expr -> [ vector ] .)
    GEQ             reduce using rule 18 (expr -> [ vector ] .)
    LEQ             reduce using rule 18 (expr -> [ vector ] .)
    >               reduce using rule 18 (expr -> [ vector ] .)
    <               reduce using rule 18 (expr -> [ vector ] .)
    TRANSPOSE       reduce using rule 18 (expr -> [ vector ] .)
    @               reduce using rule 18 (expr -> [ vector ] .)
    /               reduce using rule 18 (expr -> [ vector ] .)
    *               reduce using rule 18 (expr -> [ vector ] .)
    -               reduce using rule 18 (expr -> [ vector ] .)
    +               reduce using rule 18 (expr -> [ vector ] .)
    ;               reduce using rule 18 (expr -> [ vector ] .)
    ,               reduce using rule 18 (expr -> [ vector ] .)
    ]               reduce using rule 18 (expr -> [ vector ] .)
    )               reduce using rule 18 (expr -> [ vector ] .)
    :               reduce using rule 18 (expr -> [ vector ] .)
    RETURN          reduce using rule 18 (expr -> [ vector ] .)
    PRINT           reduce using rule 18 (expr -> [ vector ] .)
    CONTINUE        reduce using rule 18 (expr -> [ vector ] .)
    BREAK           reduce using rule 18 (expr -> [ vector ] .)
    FOR             reduce using rule 18 (expr -> [ vector ] .)
    WHILE           reduce using rule 18 (expr -> [ vector ] .)
    IF              reduce using rule 18 (expr -> [ vector ] .)
    {               reduce using rule 18 (expr -> [ vector ] .)
    ID              reduce using rule 18 (expr -> [ vector ] .)
    STRING          reduce using rule 18 (expr -> [ vector ] .)
    FLOATNUM        reduce using rule 18 (expr -> [ vector ] .)
    INTNUM          reduce using rule 18 (expr -> [ vector ] .)
    EYE             reduce using rule 18 (expr -> [ vector ] .)
    ONES            reduce using rule 18 (expr -> [ vector ] .)
    ZEROS           reduce using rule 18 (expr -> [ vector ] .)


state 91

    (26) expr -> ( expr ) .
    NEQ             reduce using rule 26 (expr -> ( expr ) .)
    EQU             reduce using rule 26 (expr -> ( expr ) .)
    GEQ             reduce using rule 26 (expr -> ( expr ) .)
    LEQ             reduce using rule 26 (expr -> ( expr ) .)
    >               reduce using rule 26 (expr -> ( expr ) .)
    <               reduce using rule 26 (expr -> ( expr ) .)
    TRANSPOSE       reduce using rule 26 (expr -> ( expr ) .)
    @               reduce using rule 26 (expr -> ( expr ) .)
    /               reduce using rule 26 (expr -> ( expr ) .)
    *               reduce using rule 26 (expr -> ( expr ) .)
    -               reduce using rule 26 (expr -> ( expr ) .)
    +               reduce using rule 26 (expr -> ( expr ) .)
    ;               reduce using rule 26 (expr -> ( expr ) .)
    ,               reduce using rule 26 (expr -> ( expr ) .)
    ]               reduce using rule 26 (expr -> ( expr ) .)
    )               reduce using rule 26 (expr -> ( expr ) .)
    :               reduce using rule 26 (expr -> ( expr ) .)
    RETURN          reduce using rule 26 (expr -> ( expr ) .)
    PRINT           reduce using rule 26 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> ( expr ) .)
    BREAK           reduce using rule 26 (expr -> ( expr ) .)
    FOR             reduce using rule 26 (expr -> ( expr ) .)
    WHILE           reduce using rule 26 (expr -> ( expr ) .)
    IF              reduce using rule 26 (expr -> ( expr ) .)
    {               reduce using rule 26 (expr -> ( expr ) .)
    ID              reduce using rule 26 (expr -> ( expr ) .)
    STRING          reduce using rule 26 (expr -> ( expr ) .)
    FLOATNUM        reduce using rule 26 (expr -> ( expr ) .)
    INTNUM          reduce using rule 26 (expr -> ( expr ) .)
    EYE             reduce using rule 26 (expr -> ( expr ) .)
    ONES            reduce using rule 26 (expr -> ( expr ) .)
    ZEROS           reduce using rule 26 (expr -> ( expr ) .)


state 92

    (8) stmt -> lvalue DIVASSIGN expr ; .
    RETURN          reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    PRINT           reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    CONTINUE        reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    BREAK           reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    FOR             reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    WHILE           reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    IF              reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    {               reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    ID              reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    STRING          reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    FLOATNUM        reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    INTNUM          reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    EYE             reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    ONES            reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    ZEROS           reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    $end            reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    }               reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)
    ELSE            reduce using rule 8 (stmt -> lvalue DIVASSIGN expr ; .)


state 93

    (9) stmt -> lvalue MULASSIGN expr ; .
    RETURN          reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    PRINT           reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    CONTINUE        reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    BREAK           reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    FOR             reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    WHILE           reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    IF              reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    {               reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    ID              reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    STRING          reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    FLOATNUM        reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    INTNUM          reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    EYE             reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    ONES            reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    ZEROS           reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    $end            reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    }               reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)
    ELSE            reduce using rule 9 (stmt -> lvalue MULASSIGN expr ; .)


state 94

    (10) stmt -> lvalue SUBASSIGN expr ; .
    RETURN          reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    PRINT           reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    CONTINUE        reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    BREAK           reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    FOR             reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    WHILE           reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    IF              reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    {               reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    ID              reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    STRING          reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    FLOATNUM        reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    INTNUM          reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    EYE             reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    ONES            reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    ZEROS           reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    $end            reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    }               reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)
    ELSE            reduce using rule 10 (stmt -> lvalue SUBASSIGN expr ; .)


state 95

    (11) stmt -> lvalue ADDASSIGN expr ; .
    RETURN          reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    PRINT           reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    CONTINUE        reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    BREAK           reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    FOR             reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    WHILE           reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    IF              reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    {               reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    ID              reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    STRING          reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    FLOATNUM        reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    INTNUM          reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    EYE             reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    ONES            reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    ZEROS           reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    $end            reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    }               reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)
    ELSE            reduce using rule 11 (stmt -> lvalue ADDASSIGN expr ; .)


state 96

    (12) stmt -> lvalue = expr ; .
    RETURN          reduce using rule 12 (stmt -> lvalue = expr ; .)
    PRINT           reduce using rule 12 (stmt -> lvalue = expr ; .)
    CONTINUE        reduce using rule 12 (stmt -> lvalue = expr ; .)
    BREAK           reduce using rule 12 (stmt -> lvalue = expr ; .)
    FOR             reduce using rule 12 (stmt -> lvalue = expr ; .)
    WHILE           reduce using rule 12 (stmt -> lvalue = expr ; .)
    IF              reduce using rule 12 (stmt -> lvalue = expr ; .)
    {               reduce using rule 12 (stmt -> lvalue = expr ; .)
    ID              reduce using rule 12 (stmt -> lvalue = expr ; .)
    STRING          reduce using rule 12 (stmt -> lvalue = expr ; .)
    FLOATNUM        reduce using rule 12 (stmt -> lvalue = expr ; .)
    INTNUM          reduce using rule 12 (stmt -> lvalue = expr ; .)
    EYE             reduce using rule 12 (stmt -> lvalue = expr ; .)
    ONES            reduce using rule 12 (stmt -> lvalue = expr ; .)
    ZEROS           reduce using rule 12 (stmt -> lvalue = expr ; .)
    $end            reduce using rule 12 (stmt -> lvalue = expr ; .)
    }               reduce using rule 12 (stmt -> lvalue = expr ; .)
    ELSE            reduce using rule 12 (stmt -> lvalue = expr ; .)


state 97

    (13) stmt -> FOR ID = expr . : expr stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    :               shift and go to state 104
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 98

    (14) stmt -> WHILE ( expr ) . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 105
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 99

    (15) stmt -> IF ( expr ) . stmt
    (16) stmt -> IF ( expr ) . stmt ELSE stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 106
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 100

    (46) lvalue -> term [ vector ] .
    DIVASSIGN       reduce using rule 46 (lvalue -> term [ vector ] .)
    MULASSIGN       reduce using rule 46 (lvalue -> term [ vector ] .)
    SUBASSIGN       reduce using rule 46 (lvalue -> term [ vector ] .)
    ADDASSIGN       reduce using rule 46 (lvalue -> term [ vector ] .)
    =               reduce using rule 46 (lvalue -> term [ vector ] .)
    [               reduce using rule 46 (lvalue -> term [ vector ] .)
    NEQ             reduce using rule 46 (lvalue -> term [ vector ] .)
    EQU             reduce using rule 46 (lvalue -> term [ vector ] .)
    GEQ             reduce using rule 46 (lvalue -> term [ vector ] .)
    LEQ             reduce using rule 46 (lvalue -> term [ vector ] .)
    >               reduce using rule 46 (lvalue -> term [ vector ] .)
    <               reduce using rule 46 (lvalue -> term [ vector ] .)
    TRANSPOSE       reduce using rule 46 (lvalue -> term [ vector ] .)
    @               reduce using rule 46 (lvalue -> term [ vector ] .)
    /               reduce using rule 46 (lvalue -> term [ vector ] .)
    *               reduce using rule 46 (lvalue -> term [ vector ] .)
    -               reduce using rule 46 (lvalue -> term [ vector ] .)
    +               reduce using rule 46 (lvalue -> term [ vector ] .)
    ;               reduce using rule 46 (lvalue -> term [ vector ] .)
    ,               reduce using rule 46 (lvalue -> term [ vector ] .)
    ]               reduce using rule 46 (lvalue -> term [ vector ] .)
    )               reduce using rule 46 (lvalue -> term [ vector ] .)
    :               reduce using rule 46 (lvalue -> term [ vector ] .)
    RETURN          reduce using rule 46 (lvalue -> term [ vector ] .)
    PRINT           reduce using rule 46 (lvalue -> term [ vector ] .)
    CONTINUE        reduce using rule 46 (lvalue -> term [ vector ] .)
    BREAK           reduce using rule 46 (lvalue -> term [ vector ] .)
    FOR             reduce using rule 46 (lvalue -> term [ vector ] .)
    WHILE           reduce using rule 46 (lvalue -> term [ vector ] .)
    IF              reduce using rule 46 (lvalue -> term [ vector ] .)
    {               reduce using rule 46 (lvalue -> term [ vector ] .)
    ID              reduce using rule 46 (lvalue -> term [ vector ] .)
    STRING          reduce using rule 46 (lvalue -> term [ vector ] .)
    FLOATNUM        reduce using rule 46 (lvalue -> term [ vector ] .)
    INTNUM          reduce using rule 46 (lvalue -> term [ vector ] .)
    EYE             reduce using rule 46 (lvalue -> term [ vector ] .)
    ONES            reduce using rule 46 (lvalue -> term [ vector ] .)
    ZEROS           reduce using rule 46 (lvalue -> term [ vector ] .)


state 101

    (41) term -> EYE ( expr ) .
    [               reduce using rule 41 (term -> EYE ( expr ) .)
    NEQ             reduce using rule 41 (term -> EYE ( expr ) .)
    EQU             reduce using rule 41 (term -> EYE ( expr ) .)
    GEQ             reduce using rule 41 (term -> EYE ( expr ) .)
    LEQ             reduce using rule 41 (term -> EYE ( expr ) .)
    >               reduce using rule 41 (term -> EYE ( expr ) .)
    <               reduce using rule 41 (term -> EYE ( expr ) .)
    TRANSPOSE       reduce using rule 41 (term -> EYE ( expr ) .)
    @               reduce using rule 41 (term -> EYE ( expr ) .)
    /               reduce using rule 41 (term -> EYE ( expr ) .)
    *               reduce using rule 41 (term -> EYE ( expr ) .)
    -               reduce using rule 41 (term -> EYE ( expr ) .)
    +               reduce using rule 41 (term -> EYE ( expr ) .)
    ;               reduce using rule 41 (term -> EYE ( expr ) .)
    ,               reduce using rule 41 (term -> EYE ( expr ) .)
    ]               reduce using rule 41 (term -> EYE ( expr ) .)
    )               reduce using rule 41 (term -> EYE ( expr ) .)
    :               reduce using rule 41 (term -> EYE ( expr ) .)
    RETURN          reduce using rule 41 (term -> EYE ( expr ) .)
    PRINT           reduce using rule 41 (term -> EYE ( expr ) .)
    CONTINUE        reduce using rule 41 (term -> EYE ( expr ) .)
    BREAK           reduce using rule 41 (term -> EYE ( expr ) .)
    FOR             reduce using rule 41 (term -> EYE ( expr ) .)
    WHILE           reduce using rule 41 (term -> EYE ( expr ) .)
    IF              reduce using rule 41 (term -> EYE ( expr ) .)
    {               reduce using rule 41 (term -> EYE ( expr ) .)
    ID              reduce using rule 41 (term -> EYE ( expr ) .)
    STRING          reduce using rule 41 (term -> EYE ( expr ) .)
    FLOATNUM        reduce using rule 41 (term -> EYE ( expr ) .)
    INTNUM          reduce using rule 41 (term -> EYE ( expr ) .)
    EYE             reduce using rule 41 (term -> EYE ( expr ) .)
    ONES            reduce using rule 41 (term -> EYE ( expr ) .)
    ZEROS           reduce using rule 41 (term -> EYE ( expr ) .)


state 102

    (42) term -> ONES ( vector ) .
    [               reduce using rule 42 (term -> ONES ( vector ) .)
    NEQ             reduce using rule 42 (term -> ONES ( vector ) .)
    EQU             reduce using rule 42 (term -> ONES ( vector ) .)
    GEQ             reduce using rule 42 (term -> ONES ( vector ) .)
    LEQ             reduce using rule 42 (term -> ONES ( vector ) .)
    >               reduce using rule 42 (term -> ONES ( vector ) .)
    <               reduce using rule 42 (term -> ONES ( vector ) .)
    TRANSPOSE       reduce using rule 42 (term -> ONES ( vector ) .)
    @               reduce using rule 42 (term -> ONES ( vector ) .)
    /               reduce using rule 42 (term -> ONES ( vector ) .)
    *               reduce using rule 42 (term -> ONES ( vector ) .)
    -               reduce using rule 42 (term -> ONES ( vector ) .)
    +               reduce using rule 42 (term -> ONES ( vector ) .)
    ;               reduce using rule 42 (term -> ONES ( vector ) .)
    ,               reduce using rule 42 (term -> ONES ( vector ) .)
    ]               reduce using rule 42 (term -> ONES ( vector ) .)
    )               reduce using rule 42 (term -> ONES ( vector ) .)
    :               reduce using rule 42 (term -> ONES ( vector ) .)
    RETURN          reduce using rule 42 (term -> ONES ( vector ) .)
    PRINT           reduce using rule 42 (term -> ONES ( vector ) .)
    CONTINUE        reduce using rule 42 (term -> ONES ( vector ) .)
    BREAK           reduce using rule 42 (term -> ONES ( vector ) .)
    FOR             reduce using rule 42 (term -> ONES ( vector ) .)
    WHILE           reduce using rule 42 (term -> ONES ( vector ) .)
    IF              reduce using rule 42 (term -> ONES ( vector ) .)
    {               reduce using rule 42 (term -> ONES ( vector ) .)
    ID              reduce using rule 42 (term -> ONES ( vector ) .)
    STRING          reduce using rule 42 (term -> ONES ( vector ) .)
    FLOATNUM        reduce using rule 42 (term -> ONES ( vector ) .)
    INTNUM          reduce using rule 42 (term -> ONES ( vector ) .)
    EYE             reduce using rule 42 (term -> ONES ( vector ) .)
    ONES            reduce using rule 42 (term -> ONES ( vector ) .)
    ZEROS           reduce using rule 42 (term -> ONES ( vector ) .)


state 103

    (43) term -> ZEROS ( vector ) .
    [               reduce using rule 43 (term -> ZEROS ( vector ) .)
    NEQ             reduce using rule 43 (term -> ZEROS ( vector ) .)
    EQU             reduce using rule 43 (term -> ZEROS ( vector ) .)
    GEQ             reduce using rule 43 (term -> ZEROS ( vector ) .)
    LEQ             reduce using rule 43 (term -> ZEROS ( vector ) .)
    >               reduce using rule 43 (term -> ZEROS ( vector ) .)
    <               reduce using rule 43 (term -> ZEROS ( vector ) .)
    TRANSPOSE       reduce using rule 43 (term -> ZEROS ( vector ) .)
    @               reduce using rule 43 (term -> ZEROS ( vector ) .)
    /               reduce using rule 43 (term -> ZEROS ( vector ) .)
    *               reduce using rule 43 (term -> ZEROS ( vector ) .)
    -               reduce using rule 43 (term -> ZEROS ( vector ) .)
    +               reduce using rule 43 (term -> ZEROS ( vector ) .)
    ;               reduce using rule 43 (term -> ZEROS ( vector ) .)
    ,               reduce using rule 43 (term -> ZEROS ( vector ) .)
    ]               reduce using rule 43 (term -> ZEROS ( vector ) .)
    )               reduce using rule 43 (term -> ZEROS ( vector ) .)
    :               reduce using rule 43 (term -> ZEROS ( vector ) .)
    RETURN          reduce using rule 43 (term -> ZEROS ( vector ) .)
    PRINT           reduce using rule 43 (term -> ZEROS ( vector ) .)
    CONTINUE        reduce using rule 43 (term -> ZEROS ( vector ) .)
    BREAK           reduce using rule 43 (term -> ZEROS ( vector ) .)
    FOR             reduce using rule 43 (term -> ZEROS ( vector ) .)
    WHILE           reduce using rule 43 (term -> ZEROS ( vector ) .)
    IF              reduce using rule 43 (term -> ZEROS ( vector ) .)
    {               reduce using rule 43 (term -> ZEROS ( vector ) .)
    ID              reduce using rule 43 (term -> ZEROS ( vector ) .)
    STRING          reduce using rule 43 (term -> ZEROS ( vector ) .)
    FLOATNUM        reduce using rule 43 (term -> ZEROS ( vector ) .)
    INTNUM          reduce using rule 43 (term -> ZEROS ( vector ) .)
    EYE             reduce using rule 43 (term -> ZEROS ( vector ) .)
    ONES            reduce using rule 43 (term -> ZEROS ( vector ) .)
    ZEROS           reduce using rule 43 (term -> ZEROS ( vector ) .)


state 104

    (13) stmt -> FOR ID = expr : . expr stmt
    (18) expr -> . [ vector ]
    (19) expr -> . term
    (20) expr -> . expr NEQ expr
    (21) expr -> . expr EQU expr
    (22) expr -> . expr GEQ expr
    (23) expr -> . expr LEQ expr
    (24) expr -> . expr > expr
    (25) expr -> . expr < expr
    (26) expr -> . ( expr )
    (27) expr -> . expr TRANSPOSE
    (28) expr -> . - expr
    (29) expr -> . + expr
    (30) expr -> . expr @ expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    [               shift and go to state 24
    (               shift and go to state 26
    -               shift and go to state 27
    +               shift and go to state 28
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20
    ID              shift and go to state 10

    expr                           shift and go to state 107
    term                           shift and go to state 25
    lvalue                         shift and go to state 29

state 105

    (14) stmt -> WHILE ( expr ) stmt .
    RETURN          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    PRINT           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    FLOATNUM        reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    INTNUM          reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    EYE             reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ONES            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ZEROS           reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    $end            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 14 (stmt -> WHILE ( expr ) stmt .)


state 106

    (15) stmt -> IF ( expr ) stmt .
    (16) stmt -> IF ( expr ) stmt . ELSE stmt
    RETURN          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    PRINT           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    FLOATNUM        reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    INTNUM          reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    EYE             reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ONES            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ZEROS           reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    $end            reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    }               reduce using rule 15 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 108


state 107

    (13) stmt -> FOR ID = expr : expr . stmt
    (20) expr -> expr . NEQ expr
    (21) expr -> expr . EQU expr
    (22) expr -> expr . GEQ expr
    (23) expr -> expr . LEQ expr
    (24) expr -> expr . > expr
    (25) expr -> expr . < expr
    (27) expr -> expr . TRANSPOSE
    (30) expr -> expr . @ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    NEQ             shift and go to state 48
    EQU             shift and go to state 49
    GEQ             shift and go to state 50
    LEQ             shift and go to state 51
    >               shift and go to state 52
    <               shift and go to state 53
    TRANSPOSE       shift and go to state 54
    @               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 109
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 108

    (16) stmt -> IF ( expr ) stmt ELSE . stmt
    (4) stmt -> . RETURN vector ;
    (5) stmt -> . PRINT vector ;
    (6) stmt -> . CONTINUE ;
    (7) stmt -> . BREAK ;
    (8) stmt -> . lvalue DIVASSIGN expr ;
    (9) stmt -> . lvalue MULASSIGN expr ;
    (10) stmt -> . lvalue SUBASSIGN expr ;
    (11) stmt -> . lvalue ADDASSIGN expr ;
    (12) stmt -> . lvalue = expr ;
    (13) stmt -> . FOR ID = expr : expr stmt
    (14) stmt -> . WHILE ( expr ) stmt
    (15) stmt -> . IF ( expr ) stmt
    (16) stmt -> . IF ( expr ) stmt ELSE stmt
    (17) stmt -> . { stmt_set }
    (45) lvalue -> . ID
    (46) lvalue -> . term [ vector ]
    (38) term -> . STRING
    (39) term -> . FLOATNUM
    (40) term -> . INTNUM
    (41) term -> . EYE ( expr )
    (42) term -> . ONES ( vector )
    (43) term -> . ZEROS ( vector )
    (44) term -> . lvalue
    RETURN          shift and go to state 4
    PRINT           shift and go to state 5
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 9
    WHILE           shift and go to state 11
    IF              shift and go to state 12
    {               shift and go to state 13
    ID              shift and go to state 10
    STRING          shift and go to state 15
    FLOATNUM        shift and go to state 16
    INTNUM          shift and go to state 17
    EYE             shift and go to state 18
    ONES            shift and go to state 19
    ZEROS           shift and go to state 20

    stmt                           shift and go to state 110
    lvalue                         shift and go to state 8
    term                           shift and go to state 14

state 109

    (13) stmt -> FOR ID = expr : expr stmt .
    RETURN          reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    PRINT           reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    CONTINUE        reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    BREAK           reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    FOR             reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    WHILE           reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    IF              reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    {               reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    ID              reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    STRING          reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    FLOATNUM        reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    INTNUM          reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    EYE             reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    ONES            reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    ZEROS           reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    $end            reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    }               reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)
    ELSE            reduce using rule 13 (stmt -> FOR ID = expr : expr stmt .)


state 110

    (16) stmt -> IF ( expr ) stmt ELSE stmt .
    RETURN          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINT           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOATNUM        reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INTNUM          reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    EYE             reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ONES            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ZEROS           reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    $end            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 16 (stmt -> IF ( expr ) stmt ELSE stmt .)
